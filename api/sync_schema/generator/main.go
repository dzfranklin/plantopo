package main

import (
	_ "embed"
	"fmt"
	"go/format"
	"os"
	"path"
	"strings"

	"github.com/iancoleman/strcase"
)

//go:embed geometry.ts
var tsGeometry string

func main() {
	workingDir := "./api/sync_schema"
	dir, err := os.ReadDir(workingDir)
	if err != nil {
		panic(err)
	}
	if err = os.Mkdir(path.Join(workingDir, "out"), 0755); err != nil {
		if !os.IsExist(err) {
			panic(err)
		}
	}

	inputs := make([]string, 0)
	for _, f := range dir {
		if f.Type().IsRegular() {
			name := f.Name()
			if strings.HasSuffix(name, ".ptschema") {
				inputs = append(inputs, name)
			}
		}
	}

	types := make([]typeIR, 0, len(inputs))
	for _, infile := range inputs {
		inschema, err := os.ReadFile(path.Join(workingDir, infile))
		if err != nil {
			panic(err)
		}
		ir := parse(infile, inschema)
		types = append(types, ir)
	}

	goGen := genGo(types)
	goOut := path.Join(workingDir, "schema.go")
	err = os.WriteFile(goOut, goGen, 0644)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Wrote %s\n", goOut)

	tsGen := genTs(types)
	tsOut := path.Join(workingDir, "out/schema.ts")
	err = os.WriteFile(tsOut, tsGen, 0644)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Wrote %s\n", tsOut)
}

type typeIR struct {
	name   string
	id     fieldIR
	fields []fieldIR
}

type fieldIR struct {
	goName      string
	jsonName    string
	goType      string
	jsonType    string
	goNonscalar bool
}

func parse(filename string, schema []byte) typeIR {
	if !strings.HasSuffix(filename, ".ptschema") {
		panic("Invalid filename: " + filename)
	}
	fileprefix := strings.TrimSuffix(filename, ".ptschema")
	ir := typeIR{
		name:   strcase.ToCamel(fileprefix),
		fields: make([]fieldIR, 0),
		id: fieldIR{
			goName:   "Id",
			jsonName: "id",
			goType:   "string",
			jsonType: "string",
		},
	}
	for _, line := range strings.Split(string(schema), "\n") {
		line := strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}
		parts := strings.Split(line, " ")
		if len(parts) != 2 {
			panic("Invalid schema line: " + line)
		}
		name := parts[0]
		ty := parts[1]
		ir.fields = append(ir.fields, fieldIR{
			goName:      name,
			jsonName:    strcase.ToLowerCamel(name),
			goType:      ty,
			jsonType:    jsonTypeFor(ty),
			goNonscalar: isGoNonscalar(ty),
		})
	}
	return ir
}

func jsonTypeFor(ty string) string {
	switch ty {
	case "string":
		return "string"
	case "float64":
		return "number"
	case "bool":
		return "boolean"
	case "Geometry":
		return "SyncGeometry"
	default:
		panic("Unsupported type: " + ty)
	}
}

func isGoNonscalar(ty string) bool {
	switch ty {
	case "Geometry":
		return true
	default:
		return false
	}
}

func genGo(types []typeIR) []byte {
	var sb strings.Builder
	sb.WriteString("// Code generated by sync_schema/gen. DO NOT EDIT.\n\n")
	sb.WriteString("package sync_schema\n\n")
	sb.WriteString(`import (
		"fmt"
		"bytes"
		"encoding/json"
		"strings"
	)` + "\n\n")
	sb.WriteString(`
	type State uint8
	const (
		Unspecified State = 0
		Unset State = 1
		Set State = 2
	)
	` + "\n\n")
	for _, ty := range types {
		gen := genGoType(ty)
		sb.Write(gen)
	}
	out, err := format.Source([]byte(sb.String()))
	if err != nil {
		fmt.Printf("Syntax error in generated code: %s\n", err)
		return []byte(sb.String())
	}
	return out
}

func genGoType(ty typeIR) []byte {
	var sb strings.Builder

	// type
	sb.WriteString(fmt.Sprintf("type %s struct {\n", ty.name))
	sb.WriteString(fmt.Sprintf("\t%s %s;\n", ty.id.goName, ty.id.goType))
	for _, field := range ty.fields {
		sb.WriteString(fmt.Sprintf("\t%sState State;\n", field.goName))
		sb.WriteString(fmt.Sprintf("\t%s %s;\n", field.goName, field.goType))
	}
	sb.WriteString("}\n\n")

	// merge
	sb.WriteString(fmt.Sprintf("func (t *%s) Merge(other %s) {\n", ty.name, ty.name))
	sb.WriteString(fmt.Sprintf("if t.%s != other.%s {\n", ty.id.goName, ty.id.goName))
	sb.WriteString(fmt.Sprintf("\tpanic(\"cannot merge %ss: id differs\")\n", ty.name))
	sb.WriteString("}\n")
	for _, field := range ty.fields {
		sb.WriteString(fmt.Sprintf("if other.%sState != Unspecified {", field.goName))
		sb.WriteString(fmt.Sprintf("t.%sState = other.%sState;", field.goName, field.goName))
		sb.WriteString(fmt.Sprintf("t.%s = other.%s;", field.goName, field.goName))
		sb.WriteString("}\n")
	}
	sb.WriteString("}\n\n")

	// unmarshal
	sb.WriteString(fmt.Sprintf("func (t *%s) UnmarshalJSON(data []byte) error {\n", ty.name))
	sb.WriteString("\tdec := json.NewDecoder(bytes.NewReader(data))\n")
	sb.WriteString("\ttok, err := dec.Token()\n")
	sb.WriteString("\tif err != nil { return err }\n")
	sb.WriteString("\tif tok != json.Delim('{') { return fmt.Errorf(\"expected '{'\") }\n")
	sb.WriteString("\tfor {\n")
	sb.WriteString("\t\ttok, err := dec.Token()\n")
	sb.WriteString("\t\tif err != nil { return err }\n")
	sb.WriteString("\t\tif tok == json.Delim('}') { break }\n")
	sb.WriteString("\t\tif key, ok := tok.(string); ok {\n")
	sb.WriteString("\t\t\tswitch key {\n")
	sb.WriteString(fmt.Sprintf("case \"%s\":\n", ty.id.jsonName))
	sb.WriteString(fmt.Sprintf("if err := dec.Decode(&t.%s); err != nil { return err }\n", ty.id.goName))
	for _, field := range ty.fields {
		sb.WriteString(fmt.Sprintf("case \"%s\":\n", field.jsonName))
		sb.WriteString("var raw json.RawMessage\n")
		sb.WriteString("if err := dec.Decode(&raw); err != nil { return err }\n")
		sb.WriteString("if bytes.Equal(raw, []byte(\"null\")) {\n")
		sb.WriteString(fmt.Sprintf("t.%sState = Unset\n", field.goName))
		sb.WriteString("} else {\n")
		sb.WriteString(fmt.Sprintf("t.%sState = Set\n", field.goName))
		sb.WriteString(fmt.Sprintf("if err := json.Unmarshal(raw, &t.%s); err != nil { return err }\n", field.goName))
		sb.WriteString("}\n")
	}
	sb.WriteString("\t\t\t}\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("return t.validate()\n")
	sb.WriteString("}\n")

	// marshal
	sb.WriteString(fmt.Sprintf("func (t %s) MarshalJSON() ([]byte, error) {\n", ty.name))
	sb.WriteString("\tvar sb strings.Builder\n")
	sb.WriteString("\tsb.WriteString(\"{\")\n\n")

	sb.WriteString(`sb.WriteString("\"` + ty.id.jsonName + `\":")` + "\n")
	sb.WriteString(fmt.Sprintf("enc, err := json.Marshal(t.%s)\n", ty.id.goName))
	sb.WriteString("if err != nil { return nil, err }\n")
	sb.WriteString("sb.Write(enc)\n\n")

	for _, field := range ty.fields {
		sb.WriteString(fmt.Sprintf("switch t.%sState {\n", field.goName))
		sb.WriteString("case Unset:\n")
		sb.WriteString(`sb.WriteString(",\"` + field.jsonName + `\":null")` + "\n")
		sb.WriteString("case Set:\n")
		sb.WriteString("value, err := json.Marshal(t." + field.goName + ")\n")
		sb.WriteString("if err != nil { return nil, err }\n")
		sb.WriteString(`sb.WriteString(",\"` + field.jsonName + `\":")` + "\n")
		sb.WriteString("sb.Write(value)\n")
		sb.WriteString("case Unspecified:\n")
		sb.WriteString("}\n\n")
	}

	sb.WriteString("sb.WriteString(\"}\")\n")
	sb.WriteString("return []byte(sb.String()), nil\n")
	sb.WriteString("}\n\n")

	return []byte(sb.String())
}

func genTs(types []typeIR) []byte {
	var sb strings.Builder
	sb.WriteString("// Code generated by sync_schema/gen. DO NOT EDIT.\n")
	sb.WriteString(strings.TrimSpace(tsGeometry))
	sb.WriteString("\n\n")
	for _, ty := range types {
		gen := genTsType(ty)
		sb.Write(gen)
	}
	return []byte(sb.String())
}

func genTsType(ty typeIR) []byte {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("export interface %sChange {\n", ty.name))
	sb.WriteString(fmt.Sprintf("\t%s: %s;\n", ty.id.jsonName, ty.id.jsonType))
	for _, field := range ty.fields {
		sb.WriteString(fmt.Sprintf("\t%s?: %s | null;\n", field.jsonName, field.jsonType))
	}
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("export function merge%s(target: %sChange, incoming: %sChange) {\n", ty.name, ty.name, ty.name))
	sb.WriteString(fmt.Sprintf("\tif (incoming.%s !== target.%s) {\n", ty.id.jsonName, ty.id.jsonName))
	sb.WriteString(fmt.Sprintf("\t\tthrow new Error('cannot merge %ss: id differs');\n", ty.name))
	sb.WriteString("\t}\n")
	for _, field := range ty.fields {
		sb.WriteString(fmt.Sprintf("\tif (incoming.%s !== undefined) {\n", field.jsonName))
		sb.WriteString(fmt.Sprintf("\t\ttarget.%s = incoming.%s;\n", field.jsonName, field.jsonName))
		sb.WriteString("\t}\n")
	}
	sb.WriteString("}\n")

	out := strings.ReplaceAll(sb.String(), "\t", "  ")
	return []byte(out)
}
