// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccessRequest = `-- name: CreateAccessRequest :one
INSERT INTO pt.access_requests
(external_id, requesting_user_id, recipient_user_id, map_internal_id, requested_role, message)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING internal_id, external_id, created_at, approved_at, implicitly_obsoleted_at, rejected_at, requesting_user_id, recipient_user_id, map_internal_id, requested_role, message
`

type CreateAccessRequestParams struct {
	ExternalID       string
	RequestingUserID pgtype.UUID
	RecipientUserID  pgtype.UUID
	MapInternalID    int64
	RequestedRole    PtMyRole
	Message          string
}

func (q *Queries) CreateAccessRequest(ctx context.Context, arg CreateAccessRequestParams) (PtAccessRequest, error) {
	row := q.db.QueryRow(ctx, createAccessRequest,
		arg.ExternalID,
		arg.RequestingUserID,
		arg.RecipientUserID,
		arg.MapInternalID,
		arg.RequestedRole,
		arg.Message,
	)
	var i PtAccessRequest
	err := row.Scan(
		&i.InternalID,
		&i.ExternalID,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.ImplicitlyObsoletedAt,
		&i.RejectedAt,
		&i.RequestingUserID,
		&i.RecipientUserID,
		&i.MapInternalID,
		&i.RequestedRole,
		&i.Message,
	)
	return i, err
}

const getAccessRequestByExternalId = `-- name: GetAccessRequestByExternalId :one
SELECT r.internal_id, r.external_id, r.created_at, approved_at, implicitly_obsoleted_at, rejected_at, requesting_user_id, recipient_user_id, map_internal_id, requested_role, message, m.internal_id, m.external_id, name, general_access_level, general_access_role, m.created_at, deleted_at, m.external_id as map_external_id
FROM pt.access_requests as r
         JOIN pt.maps m on m.internal_id = r.map_internal_id
WHERE r.external_id = $1
`

type GetAccessRequestByExternalIdRow struct {
	InternalID            int64
	ExternalID            string
	CreatedAt             pgtype.Timestamptz
	ApprovedAt            pgtype.Timestamptz
	ImplicitlyObsoletedAt pgtype.Timestamptz
	RejectedAt            pgtype.Timestamptz
	RequestingUserID      pgtype.UUID
	RecipientUserID       pgtype.UUID
	MapInternalID         int64
	RequestedRole         PtMyRole
	Message               string
	InternalID_2          int64
	ExternalID_2          string
	Name                  string
	GeneralAccessLevel    PtGeneralAccessLevel
	GeneralAccessRole     PtGeneralAccessRole
	CreatedAt_2           pgtype.Timestamptz
	DeletedAt             pgtype.Timestamptz
	MapExternalID         string
}

func (q *Queries) GetAccessRequestByExternalId(ctx context.Context, externalID string) (GetAccessRequestByExternalIdRow, error) {
	row := q.db.QueryRow(ctx, getAccessRequestByExternalId, externalID)
	var i GetAccessRequestByExternalIdRow
	err := row.Scan(
		&i.InternalID,
		&i.ExternalID,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.ImplicitlyObsoletedAt,
		&i.RejectedAt,
		&i.RequestingUserID,
		&i.RecipientUserID,
		&i.MapInternalID,
		&i.RequestedRole,
		&i.Message,
		&i.InternalID_2,
		&i.ExternalID_2,
		&i.Name,
		&i.GeneralAccessLevel,
		&i.GeneralAccessRole,
		&i.CreatedAt_2,
		&i.DeletedAt,
		&i.MapExternalID,
	)
	return i, err
}

const getMapByExternalId = `-- name: GetMapByExternalId :one
SELECT internal_id, external_id, name, general_access_level, general_access_role, created_at, deleted_at
FROM pt.maps
WHERE external_id = $1
`

func (q *Queries) GetMapByExternalId(ctx context.Context, externalID string) (PtMap, error) {
	row := q.db.QueryRow(ctx, getMapByExternalId, externalID)
	var i PtMap
	err := row.Scan(
		&i.InternalID,
		&i.ExternalID,
		&i.Name,
		&i.GeneralAccessLevel,
		&i.GeneralAccessRole,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listPendingAccessRequestsToRecipient = `-- name: ListPendingAccessRequestsToRecipient :many
SELECT r.external_id,
       r.created_at,
       r.requested_role,
       r.message,
       m.external_id as map_external_id,
       m.name        as map_name,
       u.email       as requesting_user_email,
       u.full_name   as requesting_user_full_name
FROM pt.access_requests as r
         JOIN pt.maps m on m.internal_id = r.map_internal_id
         JOIN pt.users u on u.id = r.requesting_user_id
WHERE r.recipient_user_id = $1
  AND r.approved_at IS NULL
  AND r.rejected_at IS NULL
  AND r.implicitly_obsoleted_at IS NULL
ORDER BY r.created_at DESC
`

type ListPendingAccessRequestsToRecipientRow struct {
	ExternalID             string
	CreatedAt              pgtype.Timestamptz
	RequestedRole          PtMyRole
	Message                string
	MapExternalID          string
	MapName                string
	RequestingUserEmail    string
	RequestingUserFullName string
}

func (q *Queries) ListPendingAccessRequestsToRecipient(ctx context.Context, recipientUserID pgtype.UUID) ([]ListPendingAccessRequestsToRecipientRow, error) {
	rows, err := q.db.Query(ctx, listPendingAccessRequestsToRecipient, recipientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingAccessRequestsToRecipientRow
	for rows.Next() {
		var i ListPendingAccessRequestsToRecipientRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.CreatedAt,
			&i.RequestedRole,
			&i.Message,
			&i.MapExternalID,
			&i.MapName,
			&i.RequestingUserEmail,
			&i.RequestingUserFullName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAccessRequestApproved = `-- name: MarkAccessRequestApproved :exec
UPDATE pt.access_requests
SET approved_at = NOW()
WHERE external_id = $1
  AND rejected_at IS NULL
  AND approved_at IS NULL
`

func (q *Queries) MarkAccessRequestApproved(ctx context.Context, externalID string) error {
	_, err := q.db.Exec(ctx, markAccessRequestApproved, externalID)
	return err
}

const markAccessRequestImplicitlyObsoleted = `-- name: MarkAccessRequestImplicitlyObsoleted :exec
UPDATE pt.access_requests
SET implicitly_obsoleted_at = NOW()
WHERE requesting_user_id = $1
  AND map_internal_id = $2
  AND implicitly_obsoleted_at IS NULL
`

type MarkAccessRequestImplicitlyObsoletedParams struct {
	RequestingUserID pgtype.UUID
	MapInternalID    int64
}

func (q *Queries) MarkAccessRequestImplicitlyObsoleted(ctx context.Context, arg MarkAccessRequestImplicitlyObsoletedParams) error {
	_, err := q.db.Exec(ctx, markAccessRequestImplicitlyObsoleted, arg.RequestingUserID, arg.MapInternalID)
	return err
}

const markAccessRequestRejected = `-- name: MarkAccessRequestRejected :exec
UPDATE pt.access_requests
SET rejected_at = NOW()
WHERE external_id = $1
  AND approved_at IS NULL
  AND rejected_at IS NULL
`

func (q *Queries) MarkAccessRequestRejected(ctx context.Context, externalID string) error {
	_, err := q.db.Exec(ctx, markAccessRequestRejected, externalID)
	return err
}
