-- This file was generated by tern gengen v2.2.1.
--
-- If using psql to execute this script use the --no-psqlrc, --tuples-only,
-- --quiet, and --no-align options to only output the migration SQL.
--
-- e.g. psql --no-psqlrc --tuples-only --quiet --no-align -f this_file.sql
--
-- The results can be redirected to a file where the proposed changes can be
-- inspected or the results can be piped back into psql to migrate immediately.
--
-- e.g. psql --no-psqlrc --tuples-only --quiet --no-align -f this_file.sql | psql

set tern.version = -1;
do $$
declare
	schema_version_table_exists boolean;
begin
	select to_regclass('public.schema_version') is not null into schema_version_table_exists;
	if schema_version_table_exists then
		perform set_config('tern.version', version::text, false) from public.schema_version;
	end if;
end
$$;

with migrations(version, up_sql) as (
	values
	(0,
$tern_gengen$
begin;
create table public.schema_version(version int4 not null);
insert into public.schema_version(version) values(0);
$tern_gengen$)

, (1,
$tern_gengen$
-- 001_add_uuid_func.sql
begin;
-- From <https://github.com/Betterment/postgresql-uuid-generate-v7/blob/main/uuid_generate_v7.sql> (MIT licensed)

CREATE FUNCTION
    uuid_generate_v7()
    RETURNS
        uuid
    LANGUAGE plpgsql
    PARALLEL SAFE
AS
$$
DECLARE
    -- The current UNIX timestamp in milliseconds
    unix_time_ms CONSTANT bytea NOT NULL DEFAULT substring(
            int8send((extract(epoch FROM clock_timestamp()) * 1000)::bigint) from 3);

    -- The buffer used to create the UUID, starting with the UNIX timestamp and followed by random bytes
    buffer                bytea NOT NULL DEFAULT unix_time_ms || gen_random_bytes(10);
BEGIN
    -- Set most significant 4 bits of 7th byte to 7 (for UUID v7), keeping the last 4 bits unchanged
    buffer = set_byte(buffer, 6, (b'0111' || get_byte(buffer, 6)::bit(4))::bit(8)::int);

    -- Set most significant 2 bits of 9th byte to 2 (the UUID variant specified in RFC 4122), keeping the last 6 bits unchanged
    buffer = set_byte(buffer, 8, (b'10' || get_byte(buffer, 8)::bit(6))::bit(8)::int);

    RETURN encode(buffer, 'hex');
END
$$
;$tern_gengen$)

, (2,
$tern_gengen$
-- 002_create_citext_and_pgcrypto.sql
begin;
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS pgcrypto;$tern_gengen$)

, (3,
$tern_gengen$
-- 003_add_users.sql
begin;
CREATE TABLE audit_log
(
    id      bigserial PRIMARY KEY,
    time    timestamp DEFAULT now(),
    subject text NOT NULL,
    object  text NOT NULL,
    action  text NOT NULL,
    payload JSONB
);

CREATE INDEX audit_log_subject_idx ON audit_log (subject, id);
CREATE INDEX audit_log_object_idx ON audit_log (object, id);
CREATE INDEX audit_log_action_idx ON audit_log (action, id);

CREATE TABLE users
(
    id              uuid PRIMARY KEY DEFAULT uuid_generate_v7(),
    name            text,
    email           citext NOT NULL,
    email_confirmed boolean          DEFAULT false,
    password_hash   bytea,
    created_at      timestamp        default now()
);

CREATE UNIQUE INDEX users_email_uniq ON users (email);

CREATE TABLE sessions
(
    token        text      DEFAULT 'plantoposecret_' || encode(gen_random_bytes(32), 'hex') NOT NULL PRIMARY KEY,
    user_id      uuid                                                                       NOT NULL,
    created_at   timestamp default now()                                                    NOT NULL,
    expiry_start timestamp default now()                                                    NOT NULL,
    user_agent   text,
    ip_addr      inet
);

CREATE INDEX sessions_user_id_idx ON sessions (user_id);

CREATE TABLE pending_email_confirmation_tokens
(
    email      text,
    token      text      DEFAULT encode(gen_random_bytes(64), 'hex') PRIMARY KEY,
    created_at timestamp default now()
);

CREATE TABLE pending_password_reset_tokens
(
    email      text,
    token      text      DEFAULT encode(gen_random_bytes(64), 'hex') PRIMARY KEY,
    created_at timestamp default now()
);

CREATE TABLE admins
(
    user_id uuid PRIMARY KEY references users (id)
);$tern_gengen$)

, (4,
$tern_gengen$
-- 004_sms_authz.sql
begin;
CREATE TABLE authorized_sms_senders
(
    id          uuid PRIMARY KEY DEFAULT uuid_generate_v7(),
    inserted_at timestamp DEFAULT now() NOT NULL,
    -- Use https://api.plantopo.com/admin/tel-input to format as E.164
    number_e164 text NOT NULL,
    comment     text
);

CREATE UNIQUE INDEX authorized_sms_senders_number_e164_idx ON authorized_sms_senders (number_e164);$tern_gengen$)

, (5,
$tern_gengen$
-- 005_add_british_and_irish_hills.sql
begin;
-- See <https://www.hills-database.co.uk/database_notes.html#fields> and ./cmd/import_dobih

CREATE TABLE british_and_irish_hills
(
    id             int PRIMARY KEY,
    name           text,
    point          geometry(Point, 4326),
    smc_parent_id  int references british_and_irish_hills,
    classification text[],
    map_50k        text,
    map_25k        text,
    metres         double precision,
    grid_ref       text,
    grid_ref_10    text,
    drop           double precision,
    col_grid_ref   text,
    col_height     double precision,
    feature        text,
    observations   text,
    survey         text,
    country        text,
    revision       text,
    comments       text
);

CREATE INDEX british_and_irish_hills_classification_idx ON british_and_irish_hills USING GIN (classification);$tern_gengen$)

, (6,
$tern_gengen$
-- 006_mountain_photos.sql
begin;
CREATE TABLE british_and_irish_hill_photos
(
    id          bigserial primary key,
    hill_id     int REFERENCES british_and_irish_hills NOT NULL,
    caption     text,
    licenses    text[],
    source      text                                   NOT NULL,
    size        int                                    NOT NULL,
    width       int                                    NOT NULL,
    height      int                                    NOT NULL,
    uploaded_at timestamp,
    author      text,
    source_text text,
    source_link text,
    importer    text
);$tern_gengen$)

, (7,
$tern_gengen$
-- 007_mountain_photo_order.sql
begin;
ALTER TABLE british_and_irish_hill_photos
    ADD COLUMN rank integer NOT NULL DEFAULT 0;$tern_gengen$)

, (8,
$tern_gengen$
-- 008_mountain_photo_reviewed.sql
begin;
ALTER TABLE british_and_irish_hill_photos
    ADD COLUMN reviewed boolean NOT NULL DEFAULT false;$tern_gengen$)

, (9,
$tern_gengen$
-- 009_geophotos.sql
begin;
CREATE TABLE geophotos_sources
(
    id   integer primary key,
    name text
);

INSERT INTO geophotos_sources (id, name)
VALUES (1, 'flickr'),
       (2, 'geograph');

CREATE TABLE geophotos_licenses
(
    id   integer primary key,
    name text not null,
    url  text
);

-- Match flickr IDs
INSERT INTO geophotos_licenses (id, name, url)
VALUES (0, 'All Rights Reserved', null),
       (4, 'Attribution License', 'https://creativecommons.org/licenses/by/2.0/'),
       (6, 'Attribution-NoDerivs License', 'https://creativecommons.org/licenses/by-nd/2.0/'),
       (3, 'Attribution-NonCommercial-NoDerivs License', 'https://creativecommons.org/licenses/by-nc-nd/2.0/'),
       (2, 'Attribution-NonCommercial License', 'https://creativecommons.org/licenses/by-nc/2.0/'),
       (1, 'Attribution-NonCommercial-ShareAlike License', 'https://creativecommons.org/licenses/by-nc-sa/2.0/'),
       (5, 'Attribution-ShareAlike License', 'https://creativecommons.org/licenses/by-sa/2.0/'),
       (7, 'Flickr Commons', 'https://www.flickr.com/commons/usage/'),
       (8, 'United States Government Work', 'http://www.usa.gov/copyright.shtml'),
       (9, 'Public Domain Dedication (CC0)', 'https://creativecommons.org/publicdomain/zero/1.0/'),
       (10, 'Public Domain Mark', 'https://creativecommons.org/publicdomain/mark/1.0/');

CREATE TABLE geophotos
(
    id               bigserial primary key,
    source           integer references geophotos_sources,
    source_id        text,
    index_region_id  integer,
    indexed_at       timestamptz,
    attribution_text text,
    attribution_link text,
    licenses         integer[],
    url              text    NOT NULL,
    width            integer NOT NULL,
    height           integer NOT NULL,
    small_url        text,
    small_width      integer,
    small_height     integer,
    point            geometry(Point, 4326),
    title            text,
    date_taken       timestamptz
);

CREATE INDEX geophotos_point_idx ON geophotos USING GIST (point);
CREATE UNIQUE INDEX geophotos_source_source_id_uniq ON geophotos (source, source_id);

CREATE TABLE flickr_index_regions
(
    id      serial primary key,
    name    text             NOT NULL,
    min_lng double precision NOT NULL,
    min_lat double precision NOT NULL,
    max_lng double precision NOT NULL,
    max_lat double precision NOT NULL
);

-- generated by drawing boxes on https://geojson.io and then using https://turf-sandbox.netlify.app/ `console.log(fc.features.map((f, i) => `('${prefix}${i+1}', ${turf.bbox(f).map(n => n.toFixed(6)).join(', ')})`).join(",\n"))`

INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
VALUES
    -- Highlands & Islands
    ('sct_highlands_1', -7.682294, 56.876307, -2.355369, 57.178269),
    ('sct_highlands_2', -6.564913, 56.675067, -2.915769, 56.876791),
    ('sct_highlands_3', -7.016359, 56.520860, -3.501917, 56.677065),
    ('sct_highlands_4', -6.565064, 56.085681, -4.383614, 56.253328),
    ('sct_highlands_5', -6.579002, 55.924972, -4.579292, 56.089581),
    ('sct_highlands_6', -6.667367, 55.283026, -4.909857, 55.925612),
    ('sct_highlands_7', -7.018109, 56.251179, -3.667790, 56.523271),
    ('sct_highlands_8', -7.683739, 57.177986, -2.732372, 57.410691),
    ('sct_highlands_9', -8.299363, 57.732347, -0.193797, 60.961018),
    ('sct_highlands_10', -7.685177, 57.408544, -4.360680, 57.731466);

CREATE TABLE flickr_index_progress
(
    region_id integer primary key references flickr_index_regions (id),
    latest    timestamptz NOT NULL
);

CREATE TABLE geograph_index_progress
(
    id     integer primary key, -- always 0
    latest timestamptz NOT NULL
);

INSERT INTO geograph_index_progress (id, latest)
VALUES (0, to_timestamp(0));$tern_gengen$)

, (10,
$tern_gengen$
-- 010_index_projected_geophotos.sql
begin;
-- Write your migrate up statements here

CREATE INDEX geophotos_point_3857_idx ON geophotos USING GIST (ST_Transform(point, 3857));$tern_gengen$)

, (11,
$tern_gengen$
-- 011_add_geograph_geophotos.sql
begin;
INSERT INTO geophotos_licenses (id, name, url) VALUES
    (11, 'Attribution-ShareAlike 2.5', 'http://creativecommons.org/licenses/by-sa/2.5/');

ALTER TABLE geograph_index_progress DROP COLUMN latest;
ALTER TABLE geograph_index_progress ADD COLUMN cutoff int;$tern_gengen$)

, (12,
$tern_gengen$
-- 012_alaska_geophotos.sql
begin;
INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
VALUES ('alaska', -170.730107, 52.224801, -141.016549, 72.091078);$tern_gengen$)

, (13,
$tern_gengen$
-- 013_geophotos_geography.sql
begin;
DROP INDEX geophotos_point_idx;
DROP INDEX geophotos_point_3857_idx;

ALTER TABLE geophotos
    ALTER COLUMN point
        TYPE Geography(Point, 4326)
        USING point::Geography(POINT);

CREATE INDEX geophotos_point_idx ON geophotos USING GIST (point);
CREATE INDEX geophotos_point_web_mercator_idx ON geophotos USING GIST (ST_Transform(point::geometry, 3857));$tern_gengen$)

, (14,
$tern_gengen$
-- 014_fix_flickr_indexer_loop.sql
begin;
ALTER TABLE flickr_index_progress
    ADD COLUMN page integer;
DELETE
FROM flickr_index_progress;$tern_gengen$)

, (15,
$tern_gengen$
-- 015_remove_flickr_page.sql
begin;
ALTER TABLE flickr_index_progress
    DROP COLUMN page;$tern_gengen$)

, (16,
$tern_gengen$
-- 016_geophotos_colorado.sql
begin;
INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
VALUES ('colorado', -109.024750, 37.008039, -102.071179, 40.991509);$tern_gengen$)

, (17,
$tern_gengen$
-- 017_geophotos_more_western_usa.sql
begin;
-- Write your migrate up statements here

-- generated by drawing boxes on https://geojson.io and then using https://turf-sandbox.netlify.app/ `console.log(fc.features.map((f, i) => `('${f.properties.name}', ${turf.bbox(f).map(n => n.toFixed(6)).join(', ')})`).join(",\n"))`

INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
VALUES ('idaho_montana_wyoming', -117.300243, 40.981281, -104.076804, 49.048819),
       ('new_mexico', -109.045331, 31.991670, -103.038761, 36.998386),
       ('utah', -114.046298, 37.001060, -108.994512, 40.981158),
       ('washington', -125.236779, 45.950872, -116.958356, 49.009959),
       ('oregon', -125.234222, 41.990450, -117.002834, 45.943113);$tern_gengen$)

, (18,
$tern_gengen$
-- 018_boolean_flags.sql
begin;
CREATE TABLE boolean_flags
(
    key   text primary key,
    value boolean not null
);$tern_gengen$)

, (19,
$tern_gengen$
-- 019_split_nw_usa_flickr_indexer.sql
begin;
DELETE
FROM flickr_index_regions
WHERE name = 'washington'
   OR name = 'oregon';

-- generated by drawing boxes on https://geojson.io and then using https://turf-sandbox.netlify.app/ `console.log(fc.features.map((f, i) => `('${f.properties.name}', ${turf.bbox(f).map(n => n.toFixed(6)).join(', ')})`).join(",\n"))`

INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
VALUES ('washington_e', -121.971853, 45.981415, -117.014810, 49.006975),
       ('washington_olympic', -124.747445, 47.203600, -122.856102, 48.324830),
       ('washington_sw', -124.043451, 45.806869, -121.984432, 46.908929),
       ('oregon_w', -122.314104, 42.002440, -116.997354, 45.994659),
       ('oregon_sw', -124.579652, 42.001461, -122.291031, 44.478074),
       ('california_n', -124.711211, 38.982735, -119.996380, 42.043097),
       ('yosemite_1', -121.069971, 38.077438, -118.809272, 38.980610),
       ('yosemite_2', -120.520389, 37.568844, -117.970019, 38.080821),
       ('ansel_wilderness', -119.951923, 37.130157, -117.347572, 37.567751),
       ('kings_canyon', -119.488314, 36.751375, -116.876062, 37.136388),
       ('sequoia_death_valley', -119.291226, 34.964481, -115.975981, 36.748832),
       ('los_padres', -120.303399, 34.486151, -118.677924, 35.211523);$tern_gengen$)

, (20,
$tern_gengen$
-- 020_add_geophoto_upload_date.sql
begin;
ALTER TABLE geophotos
    ADD COLUMN date_uploaded timestamptz;$tern_gengen$)

, (21,
$tern_gengen$
-- 021_settings.sql
begin;
CREATE TABLE user_settings
(
    user_id    uuid primary key references users,
    value      jsonb       NOT NULL,
    updated_at timestamptz NOT NULL
);$tern_gengen$)

, (22,
$tern_gengen$
-- 022_ids.sql
begin;
CREATE FUNCTION uuid_to_id(kind text, input uuid)
    RETURNS text
    LANGUAGE plpgsql
AS
$BODY$
DECLARE
    bytes        bytea;
    byteCount    int;
    alphabet     bytea = '0123456789abcdefghjkmnpqrstvwxyz';
    SHIFT        int   = 5; /* SHIFT is the number of bits per output character, so the length of the output is the length of the input multiplied by 8/SHIFT, rounded up.*/
    MASK         int   = 31;
    result       text  = '';
    outputLength int;
    buffer       int;
    next         int;
    bitsLeft     int;
    pad          int;
    index        int;
BEGIN
    -- Based on <https://github.com/SORMAS-Foundation/SORMAS-Project/issues/4805>

    bytes = decode(replace(input::text, '-', ''), 'hex');

    byteCount = length(bytes);
    outputLength = (byteCount * 8 + SHIFT - 1) / SHIFT;

    buffer = get_byte(bytes, 0);
    next = 1;
    bitsLeft = 8;
    while bitsLeft > 0 OR next < byteCount
        LOOP
            if (bitsLeft < SHIFT) THEN
                if (next < byteCount) THEN
                    buffer = buffer << 8;
                    buffer = buffer | (get_byte(bytes, next) & 255);
                    next = next + 1;
                    bitsLeft = bitsLeft + 8;
                ELSE
                    pad = SHIFT - bitsLeft;
                    buffer = buffer << pad;
                    bitsLeft = bitsLeft + pad;
                END IF;
            END IF;

            index = MASK & (buffer >> (bitsLeft - SHIFT));
            bitsLeft = bitsLeft - SHIFT;
            result = result || chr(get_byte(alphabet, index));
        END LOOP;
    RETURN kind || '_' || result;
END;
$BODY$;

CREATE FUNCTION id_to_uuid(kind text, input text)
    RETURNS uuid
    LANGUAGE plpgsql
AS
$BODY$
DECLARE
    alphabet  text  = '0123456789abcdefghjkmnpqrstvwxyz';
    SHIFT     int   = 5;
    result    bytea = '';
    buffer    int   = 0;
    bitsLeft  int   = 0;
    byteCount int   = 16;
    char      text;
    i         int;
    index     int;
    prefix    text;
BEGIN
    -- Extract the prefix before the underscore and verify it matches the kind
    prefix := split_part(input, '_', 1);
    IF prefix != kind THEN
        RAISE EXCEPTION 'Prefix "%" does not match the expected kind "%"', prefix, kind;
    END IF;

    -- Remove the prefix and underscore to get the encoded part
    input := split_part(input, '_', 2);

    -- Decode the input back to the byte array
    FOR i IN 1..length(input)
        LOOP
            char := substring(input, i, 1);
            index := strpos(alphabet, char) - 1;

            IF index < 0 THEN
                RAISE EXCEPTION 'Invalid character "%" in input', char;
            END IF;

            buffer := (buffer << SHIFT) | index;
            bitsLeft := bitsLeft + SHIFT;

            WHILE bitsLeft >= 8
                LOOP
                    bitsLeft := bitsLeft - 8;
                    result := result || decode(lpad(to_hex((buffer >> bitsLeft) & 255), 2, '0'), 'hex');
                END LOOP;
        END LOOP;

    -- Check if the resulting byte length is valid for a UUID
    IF length(result) != byteCount THEN
        RAISE EXCEPTION 'Invalid input length for UUID';
    END IF;

    -- Return the result as a UUID
    RETURN encode(result, 'hex')::uuid;
END;
$BODY$;

CREATE OR REPLACE FUNCTION int_to_id(kind text, input bigint)
    RETURNS text
    LANGUAGE plpgsql
AS
$BODY$
BEGIN
    return kind || '_' || input::text;
END;
$BODY$;

CREATE OR REPLACE FUNCTION id_to_int(kind text, id text)
    RETURNS bigint
    LANGUAGE plpgsql
AS
$BODY$
DECLARE
    prefix text;
    input  text;
BEGIN
    prefix := split_part(id, '_', 1);
    input := split_part(id, '_', 2);

    IF prefix != kind THEN
        RAISE EXCEPTION 'Prefix "%" does not match the expected kind "%"', prefix, kind;
    end if;

    RETURN input::bigint;
END;
$BODY$;$tern_gengen$)

, (23,
$tern_gengen$
-- 023_add_tracks.sql
begin;
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE TABLE tracks
(
    id              uuid primary key default uuid_generate_v7(),
    owner_id        uuid                        not null references users,
    name            text,
    description_md  text,
    date            timestamptz                 not null,
    date_uploaded   timestamptz                 not null,
    length_meters   double precision GENERATED ALWAYS AS ( ST_Length(line) ) STORED,
    duration_secs   integer GENERATED ALWAYS AS ( CASE
                                                      WHEN array_length(times, 1) >= 2
                                                          THEN extract('epoch' from times[array_upper(times, 1)] - times[1]) END ) STORED,
    times           timestamptz[] CHECK ( array_length(times, 1) = ST_NPoints(line::geometry) ),
    line            Geography(LineString, 4326) not null,
    line_feature_id bigserial
);

CREATE INDEX tracks_owner_id_line_3857_idx ON tracks USING GIST (owner_id, ST_Transform(line::geometry, 3857));
CREATE INDEX tracks_owner_id_idx ON tracks (owner_id);
CREATE INDEX tracks_owner_id_name_idx ON tracks (owner_id, name);
CREATE INDEX tracks_owner_id_date_idx ON tracks (owner_id, date);
CREATE INDEX tracks_owner_id_date_uploaded_idx ON tracks (owner_id, date_uploaded);$tern_gengen$)

, (24,
$tern_gengen$
-- 024_demo_user.sql
begin;
INSERT INTO users (id, name, email, email_confirmed, created_at, password_hash)
VALUES ('6e1938a8-6a56-42bb-8d72-bf4b3a7c79f3', -- u_drckha3aas1bq3bjqx5kmz3syc
        'Demo User',
        'demo@plantopo.com',
        true,
        '2024-01-01T23:24:25',
        '$2a$12$nM6Pzmn56EbHN46bt/X07OCAuEarpHglVSIP4gIEyMPd67PxWjmzu' -- password
       );$tern_gengen$)

, (25,
$tern_gengen$
-- 025_gb_postcode.sql
begin;
CREATE TABLE gb_postcode_points (
    code text primary key,
    point Geometry(Point, 4326),
    code_normalized text generated always as ( replace(code, ' ', '') ) STORED
);

CREATE INDEX gb_postcode_points_code_normalized_pattern ON gb_postcode_points (code_normalized TEXT_PATTERN_OPS);
CREATE INDEX gb_postcode_points_point ON gb_postcode_points USING GIST (point);$tern_gengen$)

, (26,
$tern_gengen$
-- 026_trigram.sql
begin;
CREATE EXTENSION IF NOT EXISTS pg_trgm;$tern_gengen$)

, (27,
$tern_gengen$
-- 027_search_british_hills.sql
begin;
CREATE TABLE british_and_irish_hill_search_terms
(
    id      bigint primary key generated always as identity,
    term    text not null,
    name    text                                       not null,
    point   geometry(Point, 4326)                      not null,
    country text                                       not null,
    hill    integer references british_and_irish_hills not null
);

CREATE INDEX british_and_irish_hill_search_terms_term_trgm_gist
    ON british_and_irish_hill_search_terms USING GIST (term gist_trgm_ops);

DO
$$
    DECLARE
        rec  RECORD;
        term TEXT;
    BEGIN
        FOR rec IN SELECT * FROM british_and_irish_hills
            LOOP
                FOREACH term IN ARRAY regexp_split_to_array(rec.name, '[-\[\]()]')
                    LOOP
                        term = regexp_replace(term, ''' ', '', 'g');
                        term = regexp_replace(term, '''', '', 'g');
                        term = regexp_replace(term, '\s+', ' ', 'g');
                        term = lower(term);
                        term = trim(term);

                        IF term != '' AND term != ' ' THEN
                            INSERT INTO british_and_irish_hill_search_terms
                                (term, name, point, country, hill)
                            VALUES (term, rec.name, rec.point, rec.country, rec.id);
                        END IF;
                    END LOOP;
            END LOOP;
    END
$$;$tern_gengen$)

)
select up_sql || '
update public.schema_version set version = ' || version || ';
commit;
'
from migrations
where version > current_setting('tern.version')::int4
order by version asc;

