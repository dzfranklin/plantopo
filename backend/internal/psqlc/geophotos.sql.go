// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: geophotos.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFlickrIndexRegion = `-- name: CreateFlickrIndexRegion :one
INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, min_lng, min_lat, max_lng, max_lat
`

type CreateFlickrIndexRegionParams struct {
	Name   string
	MinLng float64
	MinLat float64
	MaxLng float64
	MaxLat float64
}

// CreateFlickrIndexRegion
//
//	INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
//	VALUES ($1, $2, $3, $4, $5)
//	RETURNING id, name, min_lng, min_lat, max_lng, max_lat
func (q *Queries) CreateFlickrIndexRegion(ctx context.Context, db DBTX, arg CreateFlickrIndexRegionParams) (FlickrIndexRegion, error) {
	row := db.QueryRow(ctx, createFlickrIndexRegion,
		arg.Name,
		arg.MinLng,
		arg.MinLat,
		arg.MaxLng,
		arg.MaxLat,
	)
	var i FlickrIndexRegion
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MinLng,
		&i.MinLat,
		&i.MaxLng,
		&i.MaxLat,
	)
	return i, err
}

const getFlickrIndexProgress = `-- name: GetFlickrIndexProgress :one
SELECT latest
FROM flickr_index_progress
WHERE region_id = $1
`

// GetFlickrIndexProgress
//
//	SELECT latest
//	FROM flickr_index_progress
//	WHERE region_id = $1
func (q *Queries) GetFlickrIndexProgress(ctx context.Context, db DBTX, regionID int32) (pgtype.Timestamptz, error) {
	row := db.QueryRow(ctx, getFlickrIndexProgress, regionID)
	var latest pgtype.Timestamptz
	err := row.Scan(&latest)
	return latest, err
}

const insertGeophoto = `-- name: InsertGeophoto :exec
INSERT INTO geophotos (source, source_id, index_region_id, indexed_at, attribution_text,
                       attribution_link, licenses, url, width, height,
                       small_url, small_width, small_height, point, title, date_taken)
VALUES ($1, $2, $3, $4, $5,
        $6, $7, $8, $9, $10,
        $11, $12, $13, st_makepoint($14, $15), $16, $17)
ON CONFLICT (source, source_id) DO UPDATE SET index_region_id  = $3,
                                              indexed_at       = $4,
                                              attribution_text = $5,
                                              attribution_link = $6,
                                              licenses         = $7,
                                              url              = $8,
                                              width            = $9,
                                              height           = $10,
                                              small_url        = $11,
                                              small_width      = $12,
                                              small_height     = $13,
                                              point            = st_makepoint($14, $15),
                                              title            = $16,
                                              date_taken       = $17
`

type InsertGeophotoParams struct {
	Source          pgtype.Int4
	SourceID        pgtype.Text
	IndexRegionID   pgtype.Int4
	IndexedAt       pgtype.Timestamptz
	AttributionText pgtype.Text
	AttributionLink pgtype.Text
	Licenses        []int32
	Url             string
	Width           int32
	Height          int32
	SmallUrl        pgtype.Text
	SmallWidth      pgtype.Int4
	SmallHeight     pgtype.Int4
	Lng             float64
	Lat             float64
	Title           pgtype.Text
	DateTaken       pgtype.Timestamptz
}

// InsertGeophoto
//
//	INSERT INTO geophotos (source, source_id, index_region_id, indexed_at, attribution_text,
//	                       attribution_link, licenses, url, width, height,
//	                       small_url, small_width, small_height, point, title, date_taken)
//	VALUES ($1, $2, $3, $4, $5,
//	        $6, $7, $8, $9, $10,
//	        $11, $12, $13, st_makepoint($14, $15), $16, $17)
//	ON CONFLICT (source, source_id) DO UPDATE SET index_region_id  = $3,
//	                                              indexed_at       = $4,
//	                                              attribution_text = $5,
//	                                              attribution_link = $6,
//	                                              licenses         = $7,
//	                                              url              = $8,
//	                                              width            = $9,
//	                                              height           = $10,
//	                                              small_url        = $11,
//	                                              small_width      = $12,
//	                                              small_height     = $13,
//	                                              point            = st_makepoint($14, $15),
//	                                              title            = $16,
//	                                              date_taken       = $17
func (q *Queries) InsertGeophoto(ctx context.Context, db DBTX, arg InsertGeophotoParams) error {
	_, err := db.Exec(ctx, insertGeophoto,
		arg.Source,
		arg.SourceID,
		arg.IndexRegionID,
		arg.IndexedAt,
		arg.AttributionText,
		arg.AttributionLink,
		arg.Licenses,
		arg.Url,
		arg.Width,
		arg.Height,
		arg.SmallUrl,
		arg.SmallWidth,
		arg.SmallHeight,
		arg.Lng,
		arg.Lat,
		arg.Title,
		arg.DateTaken,
	)
	return err
}

const listFlickrIndexRegions = `-- name: ListFlickrIndexRegions :many
SELECT id, name, min_lng, min_lat, max_lng, max_lat
FROM flickr_index_regions
`

// ListFlickrIndexRegions
//
//	SELECT id, name, min_lng, min_lat, max_lng, max_lat
//	FROM flickr_index_regions
func (q *Queries) ListFlickrIndexRegions(ctx context.Context, db DBTX) ([]FlickrIndexRegion, error) {
	rows, err := db.Query(ctx, listFlickrIndexRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FlickrIndexRegion
	for rows.Next() {
		var i FlickrIndexRegion
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MinLng,
			&i.MinLat,
			&i.MaxLng,
			&i.MaxLat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGeophotoTile = `-- name: SelectGeophotoTile :one
WITH mvtgeom AS
         (SELECT ST_AsMVTGeom(
                         ST_Transform(point, 3857),
                         ST_TileEnvelope($1, $2, $3),
                         extent => 4096,
                         buffer => 256,
                         clip_geom => true
                 ) AS geom,
                 id
          FROM geophotos
          WHERE ST_Transform(point, 3857) && ST_TileEnvelope($1, $2, $3, margin => (64.0 / 4096)))
SELECT ST_AsMVT(mvtgeom.*, 'default', 4096, 'geom', 'id')
FROM mvtgeom
`

type SelectGeophotoTileParams struct {
	Z int32
	X int32
	Y int32
}

// SelectGeophotoTile
//
//	WITH mvtgeom AS
//	         (SELECT ST_AsMVTGeom(
//	                         ST_Transform(point, 3857),
//	                         ST_TileEnvelope($1, $2, $3),
//	                         extent => 4096,
//	                         buffer => 256,
//	                         clip_geom => true
//	                 ) AS geom,
//	                 id
//	          FROM geophotos
//	          WHERE ST_Transform(point, 3857) && ST_TileEnvelope($1, $2, $3, margin => (64.0 / 4096)))
//	SELECT ST_AsMVT(mvtgeom.*, 'default', 4096, 'geom', 'id')
//	FROM mvtgeom
func (q *Queries) SelectGeophotoTile(ctx context.Context, db DBTX, arg SelectGeophotoTileParams) ([]byte, error) {
	row := db.QueryRow(ctx, selectGeophotoTile, arg.Z, arg.X, arg.Y)
	var st_asmvt []byte
	err := row.Scan(&st_asmvt)
	return st_asmvt, err
}

const selectGeophotosByID = `-- name: SelectGeophotosByID :many
SELECT id,
       source,
       source_id,
       index_region_id,
       indexed_at,
       attribution_text,
       attribution_link,
       licenses,
       url,
       width,
       height,
       small_url,
       small_width,
       small_height,
       ST_X(point) as lng,
       ST_Y(point) as lat,
       title,
       date_taken
FROM geophotos
WHERE id = any($1::bigint[])
`

type SelectGeophotosByIDRow struct {
	ID              int64
	Source          pgtype.Int4
	SourceID        pgtype.Text
	IndexRegionID   pgtype.Int4
	IndexedAt       pgtype.Timestamptz
	AttributionText pgtype.Text
	AttributionLink pgtype.Text
	Licenses        []int32
	Url             string
	Width           int32
	Height          int32
	SmallUrl        pgtype.Text
	SmallWidth      pgtype.Int4
	SmallHeight     pgtype.Int4
	Lng             pgtype.Float8
	Lat             pgtype.Float8
	Title           pgtype.Text
	DateTaken       pgtype.Timestamptz
}

// SelectGeophotosByID
//
//	SELECT id,
//	       source,
//	       source_id,
//	       index_region_id,
//	       indexed_at,
//	       attribution_text,
//	       attribution_link,
//	       licenses,
//	       url,
//	       width,
//	       height,
//	       small_url,
//	       small_width,
//	       small_height,
//	       ST_X(point) as lng,
//	       ST_Y(point) as lat,
//	       title,
//	       date_taken
//	FROM geophotos
//	WHERE id = any($1::bigint[])
func (q *Queries) SelectGeophotosByID(ctx context.Context, db DBTX, ids []int64) ([]SelectGeophotosByIDRow, error) {
	rows, err := db.Query(ctx, selectGeophotosByID, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectGeophotosByIDRow
	for rows.Next() {
		var i SelectGeophotosByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.IndexRegionID,
			&i.IndexedAt,
			&i.AttributionText,
			&i.AttributionLink,
			&i.Licenses,
			&i.Url,
			&i.Width,
			&i.Height,
			&i.SmallUrl,
			&i.SmallWidth,
			&i.SmallHeight,
			&i.Lng,
			&i.Lat,
			&i.Title,
			&i.DateTaken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlickrIndexProgress = `-- name: UpdateFlickrIndexProgress :exec
INSERT INTO flickr_index_progress (region_id, latest)
VALUES ($1, $2)
ON CONFLICT (region_id) DO UPDATE set latest = $2
`

// UpdateFlickrIndexProgress
//
//	INSERT INTO flickr_index_progress (region_id, latest)
//	VALUES ($1, $2)
//	ON CONFLICT (region_id) DO UPDATE set latest = $2
func (q *Queries) UpdateFlickrIndexProgress(ctx context.Context, db DBTX, regionID int32, latest pgtype.Timestamptz) error {
	_, err := db.Exec(ctx, updateFlickrIndexProgress, regionID, latest)
	return err
}

const updateGeographIndexProgress = `-- name: UpdateGeographIndexProgress :exec
UPDATE geograph_index_progress
SET latest = $1
WHERE id = 0
`

// UpdateGeographIndexProgress
//
//	UPDATE geograph_index_progress
//	SET latest = $1
//	WHERE id = 0
func (q *Queries) UpdateGeographIndexProgress(ctx context.Context, db DBTX, latest pgtype.Timestamptz) error {
	_, err := db.Exec(ctx, updateGeographIndexProgress, latest)
	return err
}
