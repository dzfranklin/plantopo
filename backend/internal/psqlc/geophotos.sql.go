// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: geophotos.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFlickrIndexRegion = `-- name: CreateFlickrIndexRegion :one
INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, min_lng, min_lat, max_lng, max_lat
`

type CreateFlickrIndexRegionParams struct {
	Name   string
	MinLng float64
	MinLat float64
	MaxLng float64
	MaxLat float64
}

// CreateFlickrIndexRegion
//
//	INSERT INTO flickr_index_regions (name, min_lng, min_lat, max_lng, max_lat)
//	VALUES ($1, $2, $3, $4, $5)
//	RETURNING id, name, min_lng, min_lat, max_lng, max_lat
func (q *Queries) CreateFlickrIndexRegion(ctx context.Context, db DBTX, arg CreateFlickrIndexRegionParams) (FlickrIndexRegion, error) {
	row := db.QueryRow(ctx, createFlickrIndexRegion,
		arg.Name,
		arg.MinLng,
		arg.MinLat,
		arg.MaxLng,
		arg.MaxLat,
	)
	var i FlickrIndexRegion
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MinLng,
		&i.MinLat,
		&i.MaxLng,
		&i.MaxLat,
	)
	return i, err
}

const getFlickrIndexProgress = `-- name: GetFlickrIndexProgress :one
SELECT latest
FROM flickr_index_progress
WHERE region_id = $1
`

// GetFlickrIndexProgress
//
//	SELECT latest
//	FROM flickr_index_progress
//	WHERE region_id = $1
func (q *Queries) GetFlickrIndexProgress(ctx context.Context, db DBTX, regionID int32) (pgtype.Timestamptz, error) {
	row := db.QueryRow(ctx, getFlickrIndexProgress, regionID)
	var latest pgtype.Timestamptz
	err := row.Scan(&latest)
	return latest, err
}

const getGeographIndexProgress = `-- name: GetGeographIndexProgress :one
SELECT cutoff
FROM geograph_index_progress
WHERE id = 0
`

// GetGeographIndexProgress
//
//	SELECT cutoff
//	FROM geograph_index_progress
//	WHERE id = 0
func (q *Queries) GetGeographIndexProgress(ctx context.Context, db DBTX) (pgtype.Int4, error) {
	row := db.QueryRow(ctx, getGeographIndexProgress)
	var cutoff pgtype.Int4
	err := row.Scan(&cutoff)
	return cutoff, err
}

const importGeophotoIfNotPresent = `-- name: ImportGeophotoIfNotPresent :exec
INSERT INTO geophotos (source, source_id, index_region_id, indexed_at, attribution_text,
                       attribution_link, licenses, url, width, height,
                       small_url, small_width, small_height, point, title, date_taken)
VALUES ($1, $2, $3, $4, $5,
        $6, $7, $8, $9, $10,
        $11, $12, $13, st_makepoint($14, $15), $16, $17)
ON CONFLICT (source, source_id) DO NOTHING
`

type ImportGeophotoIfNotPresentParams struct {
	Source          pgtype.Int4
	SourceID        pgtype.Text
	IndexRegionID   pgtype.Int4
	IndexedAt       pgtype.Timestamptz
	AttributionText pgtype.Text
	AttributionLink pgtype.Text
	Licenses        []int32
	Url             string
	Width           int32
	Height          int32
	SmallUrl        pgtype.Text
	SmallWidth      pgtype.Int4
	SmallHeight     pgtype.Int4
	Lng             float64
	Lat             float64
	Title           pgtype.Text
	DateTaken       pgtype.Timestamptz
}

// ImportGeophotoIfNotPresent
//
//	INSERT INTO geophotos (source, source_id, index_region_id, indexed_at, attribution_text,
//	                       attribution_link, licenses, url, width, height,
//	                       small_url, small_width, small_height, point, title, date_taken)
//	VALUES ($1, $2, $3, $4, $5,
//	        $6, $7, $8, $9, $10,
//	        $11, $12, $13, st_makepoint($14, $15), $16, $17)
//	ON CONFLICT (source, source_id) DO NOTHING
func (q *Queries) ImportGeophotoIfNotPresent(ctx context.Context, db DBTX, arg ImportGeophotoIfNotPresentParams) error {
	_, err := db.Exec(ctx, importGeophotoIfNotPresent,
		arg.Source,
		arg.SourceID,
		arg.IndexRegionID,
		arg.IndexedAt,
		arg.AttributionText,
		arg.AttributionLink,
		arg.Licenses,
		arg.Url,
		arg.Width,
		arg.Height,
		arg.SmallUrl,
		arg.SmallWidth,
		arg.SmallHeight,
		arg.Lng,
		arg.Lat,
		arg.Title,
		arg.DateTaken,
	)
	return err
}

const listFlickrIndexRegions = `-- name: ListFlickrIndexRegions :many
SELECT id, name, min_lng, min_lat, max_lng, max_lat
FROM flickr_index_regions
`

// ListFlickrIndexRegions
//
//	SELECT id, name, min_lng, min_lat, max_lng, max_lat
//	FROM flickr_index_regions
func (q *Queries) ListFlickrIndexRegions(ctx context.Context, db DBTX) ([]FlickrIndexRegion, error) {
	rows, err := db.Query(ctx, listFlickrIndexRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FlickrIndexRegion
	for rows.Next() {
		var i FlickrIndexRegion
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MinLng,
			&i.MinLat,
			&i.MaxLng,
			&i.MaxLat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllGeophotos = `-- name: SelectAllGeophotos :many
SELECT id, ST_X(point::geometry) as lng, ST_Y(point::geometry) as lat
FROM geophotos
WHERE id > $1
ORDER BY id
LIMIT 1000
`

type SelectAllGeophotosRow struct {
	ID  int64
	Lng pgtype.Float8
	Lat pgtype.Float8
}

// SelectAllGeophotos
//
//	SELECT id, ST_X(point::geometry) as lng, ST_Y(point::geometry) as lat
//	FROM geophotos
//	WHERE id > $1
//	ORDER BY id
//	LIMIT 1000
func (q *Queries) SelectAllGeophotos(ctx context.Context, db DBTX, cursor int64) ([]SelectAllGeophotosRow, error) {
	rows, err := db.Query(ctx, selectAllGeophotos, cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllGeophotosRow
	for rows.Next() {
		var i SelectAllGeophotosRow
		if err := rows.Scan(&i.ID, &i.Lng, &i.Lat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGeophotoTile = `-- name: SelectGeophotoTile :one
SELECT ST_AsMVT(tile.*, 'default', 4096, 'geom') as tile
FROM (SELECT ST_AsMVTGeom(
                     ST_Transform(center::geometry, 3857),
                     ST_TileEnvelope($1::integer, $2::integer, $3::integer),
                     extent => 4096,
                     buffer => 256,
                     clip_geom => true
             ) AS geom,
             count
      FROM (SELECT ST_Centroid(ST_Collect(ST_Transform(point::geometry, 3857))) as center,
                   count(cluster_id)                                            as count
            FROM (SELECT ST_ClusterDBSCAN(ST_Transform(point::geometry, 3857),
                         (40075017.0 / (256 * 2 ^ $1)),
                         1) OVER () AS cluster_id,
                         point
                  FROM geophotos
                  WHERE ST_Transform(point::geometry, 3857) &&
                        ST_TileEnvelope($1::integer, $2::integer, $3::integer,
                                        margin => (64.0 / 4096))) AS cluster
            GROUP BY cluster_id) AS clusters) AS tile
`

type SelectGeophotoTileParams struct {
	Z int32
	X int32
	Y int32
}

// SelectGeophotoTile
//
//	SELECT ST_AsMVT(tile.*, 'default', 4096, 'geom') as tile
//	FROM (SELECT ST_AsMVTGeom(
//	                     ST_Transform(center::geometry, 3857),
//	                     ST_TileEnvelope($1::integer, $2::integer, $3::integer),
//	                     extent => 4096,
//	                     buffer => 256,
//	                     clip_geom => true
//	             ) AS geom,
//	             count
//	      FROM (SELECT ST_Centroid(ST_Collect(ST_Transform(point::geometry, 3857))) as center,
//	                   count(cluster_id)                                            as count
//	            FROM (SELECT ST_ClusterDBSCAN(ST_Transform(point::geometry, 3857),
//	                         (40075017.0 / (256 * 2 ^ $1)),
//	                         1) OVER () AS cluster_id,
//	                         point
//	                  FROM geophotos
//	                  WHERE ST_Transform(point::geometry, 3857) &&
//	                        ST_TileEnvelope($1::integer, $2::integer, $3::integer,
//	                                        margin => (64.0 / 4096))) AS cluster
//	            GROUP BY cluster_id) AS clusters) AS tile
func (q *Queries) SelectGeophotoTile(ctx context.Context, db DBTX, arg SelectGeophotoTileParams) ([]byte, error) {
	row := db.QueryRow(ctx, selectGeophotoTile, arg.Z, arg.X, arg.Y)
	var tile []byte
	err := row.Scan(&tile)
	return tile, err
}

const selectGeophotoTileSampled = `-- name: SelectGeophotoTileSampled :one
SELECT ST_AsMVT(tile.*, 'default', 4096, 'geom') as tile
FROM (SELECT ST_AsMVTGeom(
                     ST_Transform(center::geometry, 3857),
                     ST_TileEnvelope($1::integer, $2::integer, $3::integer),
                     extent => 4096,
                     buffer => 256,
                     clip_geom => true
             ) AS geom,
             count
      FROM (SELECT ST_Centroid(ST_Collect(ST_Transform(point::geometry, 3857))) as center,
                   count(cluster_id) * (100 / $4)                         as count
            FROM (SELECT ST_ClusterDBSCAN(ST_Transform(point::geometry, 3857),
                         (40075017.0 / (256 * 2 ^ $1)),
                         1) OVER () AS cluster_id,
                         point
                  FROM geophotos
                           TABLESAMPLE system ($4)
                  WHERE ST_Transform(point::geometry, 3857) &&
                        ST_TileEnvelope($1::integer, $2::integer, $3::integer,
                                        margin => (64.0 / 4096))) AS cluster
            GROUP BY cluster_id) AS clusters) AS tile
`

type SelectGeophotoTileSampledParams struct {
	Z       int32
	X       int32
	Y       int32
	Percent pgtype.Float4
}

// SelectGeophotoTileSampled
//
//	SELECT ST_AsMVT(tile.*, 'default', 4096, 'geom') as tile
//	FROM (SELECT ST_AsMVTGeom(
//	                     ST_Transform(center::geometry, 3857),
//	                     ST_TileEnvelope($1::integer, $2::integer, $3::integer),
//	                     extent => 4096,
//	                     buffer => 256,
//	                     clip_geom => true
//	             ) AS geom,
//	             count
//	      FROM (SELECT ST_Centroid(ST_Collect(ST_Transform(point::geometry, 3857))) as center,
//	                   count(cluster_id) * (100 / $4)                         as count
//	            FROM (SELECT ST_ClusterDBSCAN(ST_Transform(point::geometry, 3857),
//	                         (40075017.0 / (256 * 2 ^ $1)),
//	                         1) OVER () AS cluster_id,
//	                         point
//	                  FROM geophotos
//	                           TABLESAMPLE system ($4)
//	                  WHERE ST_Transform(point::geometry, 3857) &&
//	                        ST_TileEnvelope($1::integer, $2::integer, $3::integer,
//	                                        margin => (64.0 / 4096))) AS cluster
//	            GROUP BY cluster_id) AS clusters) AS tile
func (q *Queries) SelectGeophotoTileSampled(ctx context.Context, db DBTX, arg SelectGeophotoTileSampledParams) ([]byte, error) {
	row := db.QueryRow(ctx, selectGeophotoTileSampled,
		arg.Z,
		arg.X,
		arg.Y,
		arg.Percent,
	)
	var tile []byte
	err := row.Scan(&tile)
	return tile, err
}

const selectGeophotosByID = `-- name: SelectGeophotosByID :many
SELECT id,
       source,
       source_id,
       index_region_id,
       indexed_at,
       attribution_text,
       attribution_link,
       licenses,
       url,
       width,
       height,
       small_url,
       small_width,
       small_height,
       ST_X(point::geometry) as lng,
       ST_Y(point::geometry) as lat,
       title,
       date_taken
FROM geophotos
WHERE id = any ($1::bigint[])
`

type SelectGeophotosByIDRow struct {
	ID              int64
	Source          pgtype.Int4
	SourceID        pgtype.Text
	IndexRegionID   pgtype.Int4
	IndexedAt       pgtype.Timestamptz
	AttributionText pgtype.Text
	AttributionLink pgtype.Text
	Licenses        []int32
	Url             string
	Width           int32
	Height          int32
	SmallUrl        pgtype.Text
	SmallWidth      pgtype.Int4
	SmallHeight     pgtype.Int4
	Lng             pgtype.Float8
	Lat             pgtype.Float8
	Title           pgtype.Text
	DateTaken       pgtype.Timestamptz
}

// SelectGeophotosByID
//
//	SELECT id,
//	       source,
//	       source_id,
//	       index_region_id,
//	       indexed_at,
//	       attribution_text,
//	       attribution_link,
//	       licenses,
//	       url,
//	       width,
//	       height,
//	       small_url,
//	       small_width,
//	       small_height,
//	       ST_X(point::geometry) as lng,
//	       ST_Y(point::geometry) as lat,
//	       title,
//	       date_taken
//	FROM geophotos
//	WHERE id = any ($1::bigint[])
func (q *Queries) SelectGeophotosByID(ctx context.Context, db DBTX, ids []int64) ([]SelectGeophotosByIDRow, error) {
	rows, err := db.Query(ctx, selectGeophotosByID, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectGeophotosByIDRow
	for rows.Next() {
		var i SelectGeophotosByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.IndexRegionID,
			&i.IndexedAt,
			&i.AttributionText,
			&i.AttributionLink,
			&i.Licenses,
			&i.Url,
			&i.Width,
			&i.Height,
			&i.SmallUrl,
			&i.SmallWidth,
			&i.SmallHeight,
			&i.Lng,
			&i.Lat,
			&i.Title,
			&i.DateTaken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGeophotosWithin = `-- name: SelectGeophotosWithin :many
SELECT id,
       source,
       source_id,
       index_region_id,
       indexed_at,
       attribution_text,
       attribution_link,
       licenses,
       url,
       width,
       height,
       small_url,
       small_width,
       small_height,
       ST_X(point::geometry) as lng,
       ST_Y(point::geometry) as lat,
       title,
       date_taken
FROM geophotos
WHERE ST_Intersects(point, ST_MakeEnvelope($1, $2, $3, $4, 4326)::geography)
LIMIT $5
`

type SelectGeophotosWithinParams struct {
	Minlng  float64
	Minlat  float64
	Maxlng  float64
	Maxlat  float64
	MaxRows int64
}

type SelectGeophotosWithinRow struct {
	ID              int64
	Source          pgtype.Int4
	SourceID        pgtype.Text
	IndexRegionID   pgtype.Int4
	IndexedAt       pgtype.Timestamptz
	AttributionText pgtype.Text
	AttributionLink pgtype.Text
	Licenses        []int32
	Url             string
	Width           int32
	Height          int32
	SmallUrl        pgtype.Text
	SmallWidth      pgtype.Int4
	SmallHeight     pgtype.Int4
	Lng             pgtype.Float8
	Lat             pgtype.Float8
	Title           pgtype.Text
	DateTaken       pgtype.Timestamptz
}

// SelectGeophotosWithin
//
//	SELECT id,
//	       source,
//	       source_id,
//	       index_region_id,
//	       indexed_at,
//	       attribution_text,
//	       attribution_link,
//	       licenses,
//	       url,
//	       width,
//	       height,
//	       small_url,
//	       small_width,
//	       small_height,
//	       ST_X(point::geometry) as lng,
//	       ST_Y(point::geometry) as lat,
//	       title,
//	       date_taken
//	FROM geophotos
//	WHERE ST_Intersects(point, ST_MakeEnvelope($1, $2, $3, $4, 4326)::geography)
//	LIMIT $5
func (q *Queries) SelectGeophotosWithin(ctx context.Context, db DBTX, arg SelectGeophotosWithinParams) ([]SelectGeophotosWithinRow, error) {
	rows, err := db.Query(ctx, selectGeophotosWithin,
		arg.Minlng,
		arg.Minlat,
		arg.Maxlng,
		arg.Maxlat,
		arg.MaxRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectGeophotosWithinRow
	for rows.Next() {
		var i SelectGeophotosWithinRow
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.IndexRegionID,
			&i.IndexedAt,
			&i.AttributionText,
			&i.AttributionLink,
			&i.Licenses,
			&i.Url,
			&i.Width,
			&i.Height,
			&i.SmallUrl,
			&i.SmallWidth,
			&i.SmallHeight,
			&i.Lng,
			&i.Lat,
			&i.Title,
			&i.DateTaken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlickrIndexProgress = `-- name: UpdateFlickrIndexProgress :exec
INSERT INTO flickr_index_progress (region_id, latest)
VALUES ($1, $2)
ON CONFLICT (region_id) DO UPDATE set latest = $2
`

// UpdateFlickrIndexProgress
//
//	INSERT INTO flickr_index_progress (region_id, latest)
//	VALUES ($1, $2)
//	ON CONFLICT (region_id) DO UPDATE set latest = $2
func (q *Queries) UpdateFlickrIndexProgress(ctx context.Context, db DBTX, regionID int32, latest pgtype.Timestamptz) error {
	_, err := db.Exec(ctx, updateFlickrIndexProgress, regionID, latest)
	return err
}

const updateGeographIndexProgress = `-- name: UpdateGeographIndexProgress :exec
UPDATE geograph_index_progress
SET cutoff = $1
WHERE id = 0
`

// UpdateGeographIndexProgress
//
//	UPDATE geograph_index_progress
//	SET cutoff = $1
//	WHERE id = 0
func (q *Queries) UpdateGeographIndexProgress(ctx context.Context, db DBTX, cutoff pgtype.Int4) error {
	_, err := db.Exec(ctx, updateGeographIndexProgress, cutoff)
	return err
}
