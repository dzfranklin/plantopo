// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: settings.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const selectSettings = `-- name: SelectSettings :one
SELECT user_id, value, updated_at
FROM user_settings
WHERE user_id = $1
`

// SelectSettings
//
//	SELECT user_id, value, updated_at
//	FROM user_settings
//	WHERE user_id = $1
func (q *Queries) SelectSettings(ctx context.Context, db DBTX, userID pgtype.UUID) (UserSetting, error) {
	row := db.QueryRow(ctx, selectSettings, userID)
	var i UserSetting
	err := row.Scan(&i.UserID, &i.Value, &i.UpdatedAt)
	return i, err
}

const setSettings = `-- name: SetSettings :exec
INSERT INTO user_settings (user_id, value, updated_at)
VALueS ($1, $2, now())
ON CONFLICT (user_id)
    DO UPDATE SET value      = $2,
                  updated_at = now()
RETURNING user_id, value, updated_at
`

// SetSettings
//
//	INSERT INTO user_settings (user_id, value, updated_at)
//	VALueS ($1, $2, now())
//	ON CONFLICT (user_id)
//	    DO UPDATE SET value      = $2,
//	                  updated_at = now()
//	RETURNING user_id, value, updated_at
func (q *Queries) SetSettings(ctx context.Context, db DBTX, userID pgtype.UUID, newValue []byte) error {
	_, err := db.Exec(ctx, setSettings, userID, newValue)
	return err
}

const upsertSettings = `-- name: UpsertSettings :one
INSERT INTO user_settings (user_id, value, updated_at)
VALUES ($1, $2, now())
ON CONFLICT (user_id)
    DO UPDATE SET value      = user_settings.value || $2,
                  updated_at = now()
RETURNING user_id, value, updated_at
`

// UpsertSettings
//
//	INSERT INTO user_settings (user_id, value, updated_at)
//	VALUES ($1, $2, now())
//	ON CONFLICT (user_id)
//	    DO UPDATE SET value      = user_settings.value || $2,
//	                  updated_at = now()
//	RETURNING user_id, value, updated_at
func (q *Queries) UpsertSettings(ctx context.Context, db DBTX, userID pgtype.UUID, newValue []byte) (UserSetting, error) {
	row := db.QueryRow(ctx, upsertSettings, userID, newValue)
	var i UserSetting
	err := row.Scan(&i.UserID, &i.Value, &i.UpdatedAt)
	return i, err
}
