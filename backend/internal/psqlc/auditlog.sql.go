// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: auditlog.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAuditLog = `-- name: GetAuditLog :one
SELECT id, time, subject, object, action, payload
FROM audit_log
WHERE id = $1
`

// GetAuditLog
//
//	SELECT id, time, subject, object, action, payload
//	FROM audit_log
//	WHERE id = $1
func (q *Queries) GetAuditLog(ctx context.Context, db DBTX, id int64) (AuditLog, error) {
	row := db.QueryRow(ctx, getAuditLog, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.Time,
		&i.Subject,
		&i.Object,
		&i.Action,
		&i.Payload,
	)
	return i, err
}

const listAuditLog = `-- name: ListAuditLog :many
SELECT id, time, subject, object, action, payload
FROM audit_log
WHERE CASE WHEN $1::boolean THEN subject = $2::text ELSE true END
  AND CASE WHEN $3::boolean THEN object = $4::text ELSE true END
  AND CASE WHEN $5::boolean THEN action = $6::text ELSE true END
  AND CASE WHEN $7::boolean THEN id < $8 ELSE true END
  AND CASE WHEN $9::boolean THEN id > $8 ELSE true END
ORDER BY id DESC
LIMIT 100
`

type ListAuditLogParams struct {
	SubjectSpecified bool
	Subject          string
	ObjectSpecified  bool
	Object           string
	ActionSpecified  bool
	Action           string
	CursorBack       bool
	Cursor           int64
	CursorForward    bool
}

// ListAuditLog
//
//	SELECT id, time, subject, object, action, payload
//	FROM audit_log
//	WHERE CASE WHEN $1::boolean THEN subject = $2::text ELSE true END
//	  AND CASE WHEN $3::boolean THEN object = $4::text ELSE true END
//	  AND CASE WHEN $5::boolean THEN action = $6::text ELSE true END
//	  AND CASE WHEN $7::boolean THEN id < $8 ELSE true END
//	  AND CASE WHEN $9::boolean THEN id > $8 ELSE true END
//	ORDER BY id DESC
//	LIMIT 100
func (q *Queries) ListAuditLog(ctx context.Context, db DBTX, arg ListAuditLogParams) ([]AuditLog, error) {
	rows, err := db.Query(ctx, listAuditLog,
		arg.SubjectSpecified,
		arg.Subject,
		arg.ObjectSpecified,
		arg.Object,
		arg.ActionSpecified,
		arg.Action,
		arg.CursorBack,
		arg.Cursor,
		arg.CursorForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.Subject,
			&i.Object,
			&i.Action,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pushAuditLog = `-- name: PushAuditLog :exec
INSERt INTO audit_log (subject, object, action, payload)
VALUES ($1, $2, $3, $4)
`

type PushAuditLogParams struct {
	Subject string
	Object  string
	Action  string
	Payload []byte
}

// PushAuditLog
//
//	INSERt INTO audit_log (subject, object, action, payload)
//	VALUES ($1, $2, $3, $4)
func (q *Queries) PushAuditLog(ctx context.Context, db DBTX, arg PushAuditLogParams) error {
	_, err := db.Exec(ctx, pushAuditLog,
		arg.Subject,
		arg.Object,
		arg.Action,
		arg.Payload,
	)
	return err
}

const selectMaxAuditLogID = `-- name: SelectMaxAuditLogID :one
SELECT coalesce(max(id), 0)
FROM audit_log
`

// SelectMaxAuditLogID
//
//	SELECT coalesce(max(id), 0)
//	FROM audit_log
func (q *Queries) SelectMaxAuditLogID(ctx context.Context, db DBTX) (pgtype.Int8, error) {
	row := db.QueryRow(ctx, selectMaxAuditLogID)
	var coalesce pgtype.Int8
	err := row.Scan(&coalesce)
	return coalesce, err
}
