// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: users.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearEmailConfirmationTokens = `-- name: ClearEmailConfirmationTokens :exec
DELETE
FROM pending_email_confirmation_tokens
WHERE email = $1
`

// ClearEmailConfirmationTokens
//
//	DELETE
//	FROM pending_email_confirmation_tokens
//	WHERE email = $1
func (q *Queries) ClearEmailConfirmationTokens(ctx context.Context, db DBTX, email pgtype.Text) error {
	_, err := db.Exec(ctx, clearEmailConfirmationTokens, email)
	return err
}

const clearPendingPasswordResetTokens = `-- name: ClearPendingPasswordResetTokens :exec
DELETE
FROM pending_password_reset_tokens
WHERE email = $1
`

// ClearPendingPasswordResetTokens
//
//	DELETE
//	FROM pending_password_reset_tokens
//	WHERE email = $1
func (q *Queries) ClearPendingPasswordResetTokens(ctx context.Context, db DBTX, email pgtype.Text) error {
	_, err := db.Exec(ctx, clearPendingPasswordResetTokens, email)
	return err
}

const createEmailConfirmationToken = `-- name: CreateEmailConfirmationToken :one
INSERT INTO pending_email_confirmation_tokens (email, created_at)
VALUES ($1, $2)
RETURNING token
`

// CreateEmailConfirmationToken
//
//	INSERT INTO pending_email_confirmation_tokens (email, created_at)
//	VALUES ($1, $2)
//	RETURNING token
func (q *Queries) CreateEmailConfirmationToken(ctx context.Context, db DBTX, email pgtype.Text, createdAt pgtype.Timestamp) (string, error) {
	row := db.QueryRow(ctx, createEmailConfirmationToken, email, createdAt)
	var token string
	err := row.Scan(&token)
	return token, err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO pending_password_reset_tokens (email, created_at)
VALUES ($1, $2)
RETURNING token
`

// CreatePasswordResetToken
//
//	INSERT INTO pending_password_reset_tokens (email, created_at)
//	VALUES ($1, $2)
//	RETURNING token
func (q *Queries) CreatePasswordResetToken(ctx context.Context, db DBTX, email pgtype.Text, createdAt pgtype.Timestamp) (string, error) {
	row := db.QueryRow(ctx, createPasswordResetToken, email, createdAt)
	var token string
	err := row.Scan(&token)
	return token, err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO users (email, name, password_hash)
VALUES ($1, $2, $3)
RETURNING id, name, email, email_confirmed, password_hash, created_at
`

type InsertUserParams struct {
	Email        string
	Name         pgtype.Text
	PasswordHash []byte
}

// InsertUser
//
//	INSERT INTO users (email, name, password_hash)
//	VALUES ($1, $2, $3)
//	RETURNING id, name, email, email_confirmed, password_hash, created_at
func (q *Queries) InsertUser(ctx context.Context, db DBTX, arg InsertUserParams) (User, error) {
	row := db.QueryRow(ctx, insertUser, arg.Email, arg.Name, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailConfirmed,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, email_confirmed, password_hash, created_at
FROM users
WHERE CASE WHEN $1::bool THEN id < $2 ELSE true END
ORDER BY id DESC
LIMIT 100
`

// ListUsers
//
//	SELECT id, name, email, email_confirmed, password_hash, created_at
//	FROM users
//	WHERE CASE WHEN $1::bool THEN id < $2 ELSE true END
//	ORDER BY id DESC
//	LIMIT 100
func (q *Queries) ListUsers(ctx context.Context, db DBTX, cursorProvided bool, cursor pgtype.UUID) ([]User, error) {
	rows, err := db.Query(ctx, listUsers, cursorProvided, cursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.EmailConfirmed,
			&i.PasswordHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markUserEmailConfirmed = `-- name: MarkUserEmailConfirmed :exec
UPDATE users
SET email_confirmed = true
WHERE id = $1
`

// MarkUserEmailConfirmed
//
//	UPDATE users
//	SET email_confirmed = true
//	WHERE id = $1
func (q *Queries) MarkUserEmailConfirmed(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, markUserEmailConfirmed, id)
	return err
}

const selectEmailConfirmationToken = `-- name: SelectEmailConfirmationToken :one
SELECT email, token, created_at
FROM pending_email_confirmation_tokens
WHERE token = $1
`

// SelectEmailConfirmationToken
//
//	SELECT email, token, created_at
//	FROM pending_email_confirmation_tokens
//	WHERE token = $1
func (q *Queries) SelectEmailConfirmationToken(ctx context.Context, db DBTX, token string) (PendingEmailConfirmationToken, error) {
	row := db.QueryRow(ctx, selectEmailConfirmationToken, token)
	var i PendingEmailConfirmationToken
	err := row.Scan(&i.Email, &i.Token, &i.CreatedAt)
	return i, err
}

const selectIsAdmin = `-- name: SelectIsAdmin :one
SELECT exists(SELECT 1 FROM admins WHERE user_id = $1)
`

// SelectIsAdmin
//
//	SELECT exists(SELECT 1 FROM admins WHERE user_id = $1)
func (q *Queries) SelectIsAdmin(ctx context.Context, db DBTX, userID pgtype.UUID) (bool, error) {
	row := db.QueryRow(ctx, selectIsAdmin, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const selectPasswordResetToken = `-- name: SelectPasswordResetToken :one
SELECT email, token, created_at
FROM pending_password_reset_tokens
WHERE token = $1
`

// SelectPasswordResetToken
//
//	SELECT email, token, created_at
//	FROM pending_password_reset_tokens
//	WHERE token = $1
func (q *Queries) SelectPasswordResetToken(ctx context.Context, db DBTX, token string) (PendingPasswordResetToken, error) {
	row := db.QueryRow(ctx, selectPasswordResetToken, token)
	var i PendingPasswordResetToken
	err := row.Scan(&i.Email, &i.Token, &i.CreatedAt)
	return i, err
}

const selectUser = `-- name: SelectUser :one
SELECT id, name, email, email_confirmed, password_hash, created_at
FROM users
WHERE id = $1
`

// SelectUser
//
//	SELECT id, name, email, email_confirmed, password_hash, created_at
//	FROM users
//	WHERE id = $1
func (q *Queries) SelectUser(ctx context.Context, db DBTX, id pgtype.UUID) (User, error) {
	row := db.QueryRow(ctx, selectUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailConfirmed,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const selectUserByEmail = `-- name: SelectUserByEmail :one
SELECT id, name, email, email_confirmed, password_hash, created_at
FROM users
WHERE email = $1::text
`

// SelectUserByEmail
//
//	SELECT id, name, email, email_confirmed, password_hash, created_at
//	FROM users
//	WHERE email = $1::text
func (q *Queries) SelectUserByEmail(ctx context.Context, db DBTX, email string) (User, error) {
	row := db.QueryRow(ctx, selectUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailConfirmed,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}
