// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: british_and_irish_hills.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveBritishAndIrishHillPhoto = `-- name: ApproveBritishAndIrishHillPhoto :exec

UPDATE british_and_irish_hill_photos
SET reviewed = true
WHERE id = $1
`

// ApproveBritishAndIrishHillPhoto
//
//	UPDATE british_and_irish_hill_photos
//	SET reviewed = true
//	WHERE id = $1
func (q *Queries) ApproveBritishAndIrishHillPhoto(ctx context.Context, db DBTX, id int64) error {
	_, err := db.Exec(ctx, approveBritishAndIrishHillPhoto, id)
	return err
}

const insertBritishAndIrishHillsPhoto = `-- name: InsertBritishAndIrishHillsPhoto :exec

INSERT INTO british_and_irish_hill_photos
(hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer)
VALUES ($1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10, $11, $12)
`

type InsertBritishAndIrishHillsPhotoParams struct {
	HillID     int32
	Caption    pgtype.Text
	Licenses   []string
	Source     string
	Size       int32
	Width      int32
	Height     int32
	UploadedAt pgtype.Timestamp
	Author     pgtype.Text
	SourceText pgtype.Text
	SourceLink pgtype.Text
	Importer   pgtype.Text
}

// InsertBritishAndIrishHillsPhoto
//
//	INSERT INTO british_and_irish_hill_photos
//	(hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer)
//	VALUES ($1, $2, $3, $4, $5, $6, $7,
//	        $8, $9, $10, $11, $12)
func (q *Queries) InsertBritishAndIrishHillsPhoto(ctx context.Context, db DBTX, arg InsertBritishAndIrishHillsPhotoParams) error {
	_, err := db.Exec(ctx, insertBritishAndIrishHillsPhoto,
		arg.HillID,
		arg.Caption,
		arg.Licenses,
		arg.Source,
		arg.Size,
		arg.Width,
		arg.Height,
		arg.UploadedAt,
		arg.Author,
		arg.SourceText,
		arg.SourceLink,
		arg.Importer,
	)
	return err
}

const listBritishAndIrishHillPhotosOf = `-- name: ListBritishAndIrishHillPhotosOf :many

SELECT id, hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer, rank, reviewed
FROM british_and_irish_hill_photos
WHERE hill_id = ANY ($1::int[])
ORDER BY rank DESC
`

// ListBritishAndIrishHillPhotosOf
//
//	SELECT id, hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer, rank, reviewed
//	FROM british_and_irish_hill_photos
//	WHERE hill_id = ANY ($1::int[])
//	ORDER BY rank DESC
func (q *Queries) ListBritishAndIrishHillPhotosOf(ctx context.Context, db DBTX, hills []int32) ([]BritishAndIrishHillPhoto, error) {
	rows, err := db.Query(ctx, listBritishAndIrishHillPhotosOf, hills)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BritishAndIrishHillPhoto
	for rows.Next() {
		var i BritishAndIrishHillPhoto
		if err := rows.Scan(
			&i.ID,
			&i.HillID,
			&i.Caption,
			&i.Licenses,
			&i.Source,
			&i.Size,
			&i.Width,
			&i.Height,
			&i.UploadedAt,
			&i.Author,
			&i.SourceText,
			&i.SourceLink,
			&i.Importer,
			&i.Rank,
			&i.Reviewed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBritishAndIrishHills = `-- name: ListBritishAndIrishHills :many

SELECT id,
       ST_X(point) as lng,
       ST_Y(point) as lat,
       name,
       smc_parent_id,
       classification,
       map_50k,
       map_25k,
       metres,
       grid_ref,
       grid_ref_10,
       drop,
       col_grid_ref,
       col_height,
       feature,
       observations,
       survey,
       country,
       revision,
       comments
FROM british_and_irish_hills
WHERE CASE
          WHEN $1::boolean THEN classification @> $2
          ELSE true END
ORDER BY id
`

type ListBritishAndIrishHillsRow struct {
	ID             int32
	Lng            pgtype.Float8
	Lat            pgtype.Float8
	Name           pgtype.Text
	SmcParentID    pgtype.Int4
	Classification []string
	Map50k         pgtype.Text
	Map25k         pgtype.Text
	Metres         pgtype.Float8
	GridRef        pgtype.Text
	GridRef10      pgtype.Text
	Drop           pgtype.Float8
	ColGridRef     pgtype.Text
	ColHeight      pgtype.Float8
	Feature        pgtype.Text
	Observations   pgtype.Text
	Survey         pgtype.Text
	Country        pgtype.Text
	Revision       pgtype.Text
	Comments       pgtype.Text
}

// ListBritishAndIrishHills
//
//	SELECT id,
//	       ST_X(point) as lng,
//	       ST_Y(point) as lat,
//	       name,
//	       smc_parent_id,
//	       classification,
//	       map_50k,
//	       map_25k,
//	       metres,
//	       grid_ref,
//	       grid_ref_10,
//	       drop,
//	       col_grid_ref,
//	       col_height,
//	       feature,
//	       observations,
//	       survey,
//	       country,
//	       revision,
//	       comments
//	FROM british_and_irish_hills
//	WHERE CASE
//	          WHEN $1::boolean THEN classification @> $2
//	          ELSE true END
//	ORDER BY id
func (q *Queries) ListBritishAndIrishHills(ctx context.Context, db DBTX, classificationContainsSpecified bool, classificationContains []string) ([]ListBritishAndIrishHillsRow, error) {
	rows, err := db.Query(ctx, listBritishAndIrishHills, classificationContainsSpecified, classificationContains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBritishAndIrishHillsRow
	for rows.Next() {
		var i ListBritishAndIrishHillsRow
		if err := rows.Scan(
			&i.ID,
			&i.Lng,
			&i.Lat,
			&i.Name,
			&i.SmcParentID,
			&i.Classification,
			&i.Map50k,
			&i.Map25k,
			&i.Metres,
			&i.GridRef,
			&i.GridRef10,
			&i.Drop,
			&i.ColGridRef,
			&i.ColHeight,
			&i.Feature,
			&i.Observations,
			&i.Survey,
			&i.Country,
			&i.Revision,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectBritishAndIrishHill = `-- name: SelectBritishAndIrishHill :one

SELECT id,
       ST_X(point) as lng,
       ST_Y(point) as lat,
       name,
       smc_parent_id,
       classification,
       map_50k,
       map_25k,
       metres,
       grid_ref,
       grid_ref_10,
       drop,
       col_grid_ref,
       col_height,
       feature,
       observations,
       survey,
       country,
       revision,
       comments
FROM british_and_irish_hills
WHERE id = $1
`

type SelectBritishAndIrishHillRow struct {
	ID             int32
	Lng            pgtype.Float8
	Lat            pgtype.Float8
	Name           pgtype.Text
	SmcParentID    pgtype.Int4
	Classification []string
	Map50k         pgtype.Text
	Map25k         pgtype.Text
	Metres         pgtype.Float8
	GridRef        pgtype.Text
	GridRef10      pgtype.Text
	Drop           pgtype.Float8
	ColGridRef     pgtype.Text
	ColHeight      pgtype.Float8
	Feature        pgtype.Text
	Observations   pgtype.Text
	Survey         pgtype.Text
	Country        pgtype.Text
	Revision       pgtype.Text
	Comments       pgtype.Text
}

// SelectBritishAndIrishHill
//
//	SELECT id,
//	       ST_X(point) as lng,
//	       ST_Y(point) as lat,
//	       name,
//	       smc_parent_id,
//	       classification,
//	       map_50k,
//	       map_25k,
//	       metres,
//	       grid_ref,
//	       grid_ref_10,
//	       drop,
//	       col_grid_ref,
//	       col_height,
//	       feature,
//	       observations,
//	       survey,
//	       country,
//	       revision,
//	       comments
//	FROM british_and_irish_hills
//	WHERE id = $1
func (q *Queries) SelectBritishAndIrishHill(ctx context.Context, db DBTX, id int32) (SelectBritishAndIrishHillRow, error) {
	row := db.QueryRow(ctx, selectBritishAndIrishHill, id)
	var i SelectBritishAndIrishHillRow
	err := row.Scan(
		&i.ID,
		&i.Lng,
		&i.Lat,
		&i.Name,
		&i.SmcParentID,
		&i.Classification,
		&i.Map50k,
		&i.Map25k,
		&i.Metres,
		&i.GridRef,
		&i.GridRef10,
		&i.Drop,
		&i.ColGridRef,
		&i.ColHeight,
		&i.Feature,
		&i.Observations,
		&i.Survey,
		&i.Country,
		&i.Revision,
		&i.Comments,
	)
	return i, err
}

const selectOneUnreviewedBritishAndIrishHillPhoto = `-- name: SelectOneUnreviewedBritishAndIrishHillPhoto :one

SELECT id, hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer, rank, reviewed
FROM british_and_irish_hill_photos
WHERE NOT reviewed
LIMIT 1
`

// SelectOneUnreviewedBritishAndIrishHillPhoto
//
//	SELECT id, hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer, rank, reviewed
//	FROM british_and_irish_hill_photos
//	WHERE NOT reviewed
//	LIMIT 1
func (q *Queries) SelectOneUnreviewedBritishAndIrishHillPhoto(ctx context.Context, db DBTX) (BritishAndIrishHillPhoto, error) {
	row := db.QueryRow(ctx, selectOneUnreviewedBritishAndIrishHillPhoto)
	var i BritishAndIrishHillPhoto
	err := row.Scan(
		&i.ID,
		&i.HillID,
		&i.Caption,
		&i.Licenses,
		&i.Source,
		&i.Size,
		&i.Width,
		&i.Height,
		&i.UploadedAt,
		&i.Author,
		&i.SourceText,
		&i.SourceLink,
		&i.Importer,
		&i.Rank,
		&i.Reviewed,
	)
	return i, err
}

const trigramSearchBritishAndIrishHills = `-- name: TrigramSearchBritishAndIrishHills :many
SELECT name, term, point, country, hill
FROM british_and_irish_hill_search_terms
ORDER BY term <-> $1
LIMIT 100
`

type TrigramSearchBritishAndIrishHillsRow struct {
	Name    string
	Term    string
	Point   Point
	Country string
	Hill    int32
}

// TrigramSearchBritishAndIrishHills
//
//	SELECT name, term, point, country, hill
//	FROM british_and_irish_hill_search_terms
//	ORDER BY term <-> $1
//	LIMIT 100
func (q *Queries) TrigramSearchBritishAndIrishHills(ctx context.Context, db DBTX, term string) ([]TrigramSearchBritishAndIrishHillsRow, error) {
	rows, err := db.Query(ctx, trigramSearchBritishAndIrishHills, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrigramSearchBritishAndIrishHillsRow
	for rows.Next() {
		var i TrigramSearchBritishAndIrishHillsRow
		if err := rows.Scan(
			&i.Name,
			&i.Term,
			&i.Point,
			&i.Country,
			&i.Hill,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
