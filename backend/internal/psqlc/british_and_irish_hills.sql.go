// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: british_and_irish_hills.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertBritishAndIrishHillsPhoto = `-- name: InsertBritishAndIrishHillsPhoto :exec

INSERT INTO british_and_irish_hill_photos
(hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer)
VALUES ($1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10, $11, $12)
`

type InsertBritishAndIrishHillsPhotoParams struct {
	HillID     int32
	Caption    pgtype.Text
	Licenses   []string
	Source     string
	Size       int32
	Width      int32
	Height     int32
	UploadedAt pgtype.Timestamp
	Author     pgtype.Text
	SourceText pgtype.Text
	SourceLink pgtype.Text
	Importer   pgtype.Text
}

// InsertBritishAndIrishHillsPhoto
//
//	INSERT INTO british_and_irish_hill_photos
//	(hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer)
//	VALUES ($1, $2, $3, $4, $5, $6, $7,
//	        $8, $9, $10, $11, $12)
func (q *Queries) InsertBritishAndIrishHillsPhoto(ctx context.Context, db DBTX, arg InsertBritishAndIrishHillsPhotoParams) error {
	_, err := db.Exec(ctx, insertBritishAndIrishHillsPhoto,
		arg.HillID,
		arg.Caption,
		arg.Licenses,
		arg.Source,
		arg.Size,
		arg.Width,
		arg.Height,
		arg.UploadedAt,
		arg.Author,
		arg.SourceText,
		arg.SourceLink,
		arg.Importer,
	)
	return err
}

const listBritishAndIrishHillPhotosOf = `-- name: ListBritishAndIrishHillPhotosOf :many

SELECT id, hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer
FROM british_and_irish_hill_photos
WHERE hill_id = ANY ($1::int[])
`

// ListBritishAndIrishHillPhotosOf
//
//	SELECT id, hill_id, caption, licenses, source, size, width, height, uploaded_at, author, source_text, source_link, importer
//	FROM british_and_irish_hill_photos
//	WHERE hill_id = ANY ($1::int[])
func (q *Queries) ListBritishAndIrishHillPhotosOf(ctx context.Context, db DBTX, hills []int32) ([]BritishAndIrishHillPhoto, error) {
	rows, err := db.Query(ctx, listBritishAndIrishHillPhotosOf, hills)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BritishAndIrishHillPhoto
	for rows.Next() {
		var i BritishAndIrishHillPhoto
		if err := rows.Scan(
			&i.ID,
			&i.HillID,
			&i.Caption,
			&i.Licenses,
			&i.Source,
			&i.Size,
			&i.Width,
			&i.Height,
			&i.UploadedAt,
			&i.Author,
			&i.SourceText,
			&i.SourceLink,
			&i.Importer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBritishAndIrishHills = `-- name: ListBritishAndIrishHills :many

SELECT id,
       ST_X(point) as lng,
       ST_Y(point) as lat,
       name,
       smc_parent_id,
       classification,
       map_50k,
       map_25k,
       metres,
       grid_ref,
       grid_ref_10,
       drop,
       col_grid_ref,
       col_height,
       feature,
       observations,
       survey,
       country,
       revision,
       comments
FROM british_and_irish_hills
WHERE CASE
          WHEN $1::boolean THEN classification @> $2
          ELSE true END
ORDER BY id
`

type ListBritishAndIrishHillsRow struct {
	ID             int32
	Lng            pgtype.Float8
	Lat            pgtype.Float8
	Name           pgtype.Text
	SmcParentID    pgtype.Int4
	Classification []string
	Map50k         pgtype.Text
	Map25k         pgtype.Text
	Metres         pgtype.Float8
	GridRef        pgtype.Text
	GridRef10      pgtype.Text
	Drop           pgtype.Float8
	ColGridRef     pgtype.Text
	ColHeight      pgtype.Float8
	Feature        pgtype.Text
	Observations   pgtype.Text
	Survey         pgtype.Text
	Country        pgtype.Text
	Revision       pgtype.Text
	Comments       pgtype.Text
}

// ListBritishAndIrishHills
//
//	SELECT id,
//	       ST_X(point) as lng,
//	       ST_Y(point) as lat,
//	       name,
//	       smc_parent_id,
//	       classification,
//	       map_50k,
//	       map_25k,
//	       metres,
//	       grid_ref,
//	       grid_ref_10,
//	       drop,
//	       col_grid_ref,
//	       col_height,
//	       feature,
//	       observations,
//	       survey,
//	       country,
//	       revision,
//	       comments
//	FROM british_and_irish_hills
//	WHERE CASE
//	          WHEN $1::boolean THEN classification @> $2
//	          ELSE true END
//	ORDER BY id
func (q *Queries) ListBritishAndIrishHills(ctx context.Context, db DBTX, classificationContainsSpecified bool, classificationContains []string) ([]ListBritishAndIrishHillsRow, error) {
	rows, err := db.Query(ctx, listBritishAndIrishHills, classificationContainsSpecified, classificationContains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBritishAndIrishHillsRow
	for rows.Next() {
		var i ListBritishAndIrishHillsRow
		if err := rows.Scan(
			&i.ID,
			&i.Lng,
			&i.Lat,
			&i.Name,
			&i.SmcParentID,
			&i.Classification,
			&i.Map50k,
			&i.Map25k,
			&i.Metres,
			&i.GridRef,
			&i.GridRef10,
			&i.Drop,
			&i.ColGridRef,
			&i.ColHeight,
			&i.Feature,
			&i.Observations,
			&i.Survey,
			&i.Country,
			&i.Revision,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
