// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tracks.sql

package psqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteTrack = `-- name: DeleteTrack :exec
DELETE
FROM tracks
WHERE id = $1
`

// DeleteTrack
//
//	DELETE
//	FROM tracks
//	WHERE id = $1
func (q *Queries) DeleteTrack(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteTrack, id)
	return err
}

const insertTrack = `-- name: InsertTrack :one
INSERT INTO tracks (owner_id, name, description_md, date, date_uploaded, times, line)
VALUES ($1, $2, $3, $4, now(),
        $5, $6)
RETURNING id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
`

type InsertTrackParams struct {
	OwnerID       pgtype.UUID
	Name          pgtype.Text
	DescriptionMd pgtype.Text
	Date          pgtype.Timestamptz
	Times         pgtype.Array[pgtype.Timestamptz]
	Line          Geometry
}

// InsertTrack
//
//	INSERT INTO tracks (owner_id, name, description_md, date, date_uploaded, times, line)
//	VALUES ($1, $2, $3, $4, now(),
//	        $5, $6)
//	RETURNING id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
func (q *Queries) InsertTrack(ctx context.Context, db DBTX, arg InsertTrackParams) (Track, error) {
	row := db.QueryRow(ctx, insertTrack,
		arg.OwnerID,
		arg.Name,
		arg.DescriptionMd,
		arg.Date,
		arg.Times,
		arg.Line,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.DescriptionMd,
		&i.Date,
		&i.DateUploaded,
		&i.LengthMeters,
		&i.DurationSecs,
		&i.Times,
		&i.Line,
		&i.LineFeatureID,
	)
	return i, err
}

const searchTracks = `-- name: SearchTracks :many
SELECT id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
FROM tracks
WHERE owner_id = $1
ORDER BY CASE WHEN $2 THEN name END,
         CASE WHEN $3 THEN date END,
         CASE WHEN $4 THEN date END desc,
         CASE WHEN $5 THEN date_uploaded END,
         CASE WHEN $6 THEN date_uploaded END desc
OFFSET $7 LIMIT $8
`

type SearchTracksParams struct {
	OwnerID                 pgtype.UUID
	OrderByName             pgtype.Bool
	OrderByDateAsc          pgtype.Bool
	OrderByDateDesc         pgtype.Bool
	OrderByDateUploadedAsc  pgtype.Bool
	OrderByDateUploadedDesc pgtype.Bool
	OffsetValue             int64
	LimitValue              int64
}

// SearchTracks
//
//	SELECT id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
//	FROM tracks
//	WHERE owner_id = $1
//	ORDER BY CASE WHEN $2 THEN name END,
//	         CASE WHEN $3 THEN date END,
//	         CASE WHEN $4 THEN date END desc,
//	         CASE WHEN $5 THEN date_uploaded END,
//	         CASE WHEN $6 THEN date_uploaded END desc
//	OFFSET $7 LIMIT $8
func (q *Queries) SearchTracks(ctx context.Context, db DBTX, arg SearchTracksParams) ([]Track, error) {
	rows, err := db.Query(ctx, searchTracks,
		arg.OwnerID,
		arg.OrderByName,
		arg.OrderByDateAsc,
		arg.OrderByDateDesc,
		arg.OrderByDateUploadedAsc,
		arg.OrderByDateUploadedDesc,
		arg.OffsetValue,
		arg.LimitValue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.DescriptionMd,
			&i.Date,
			&i.DateUploaded,
			&i.LengthMeters,
			&i.DurationSecs,
			&i.Times,
			&i.Line,
			&i.LineFeatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTracksTile = `-- name: SearchTracksTile :one
WITH mvtgeom AS
         (SELECT ST_AsMVTGeom(
                         ST_Transform(line::geometry, 3857),
                         ST_TileEnvelope($1, $2, $3), extent => 4096,
                         buffer => 64
                 )                         AS geom,
                 uuid_to_id('t', id)       as id,
                 uuid_to_id('u', owner_id) as owner_id,
                 name,
                 line_feature_id
          FROM tracks
          WHERE owner_id = $4
            AND ST_Transform(line::geometry, 3857) &&
                ST_TileEnvelope($1, $2, $3, margin => (64.0 / 4096)))
SELECT ST_AsMVT(mvtgeom, 'default', 4096, 'geom', 'line_feature_id')
FROM mvtgeom
`

type SearchTracksTileParams struct {
	Z       int32
	X       int32
	Y       int32
	OwnerID pgtype.UUID
}

// SearchTracksTile
//
//	WITH mvtgeom AS
//	         (SELECT ST_AsMVTGeom(
//	                         ST_Transform(line::geometry, 3857),
//	                         ST_TileEnvelope($1, $2, $3), extent => 4096,
//	                         buffer => 64
//	                 )                         AS geom,
//	                 uuid_to_id('t', id)       as id,
//	                 uuid_to_id('u', owner_id) as owner_id,
//	                 name,
//	                 line_feature_id
//	          FROM tracks
//	          WHERE owner_id = $4
//	            AND ST_Transform(line::geometry, 3857) &&
//	                ST_TileEnvelope($1, $2, $3, margin => (64.0 / 4096)))
//	SELECT ST_AsMVT(mvtgeom, 'default', 4096, 'geom', 'line_feature_id')
//	FROM mvtgeom
func (q *Queries) SearchTracksTile(ctx context.Context, db DBTX, arg SearchTracksTileParams) ([]byte, error) {
	row := db.QueryRow(ctx, searchTracksTile,
		arg.Z,
		arg.X,
		arg.Y,
		arg.OwnerID,
	)
	var st_asmvt []byte
	err := row.Scan(&st_asmvt)
	return st_asmvt, err
}

const selectTrack = `-- name: SelectTrack :one
SELECT id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
FROM tracks
WHERE id = $1
`

// SelectTrack
//
//	SELECT id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
//	FROM tracks
//	WHERE id = $1
func (q *Queries) SelectTrack(ctx context.Context, db DBTX, id pgtype.UUID) (Track, error) {
	row := db.QueryRow(ctx, selectTrack, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.DescriptionMd,
		&i.Date,
		&i.DateUploaded,
		&i.LengthMeters,
		&i.DurationSecs,
		&i.Times,
		&i.Line,
		&i.LineFeatureID,
	)
	return i, err
}

const updateTrack = `-- name: UpdateTrack :one
UPDATE tracks
SET name           = $1,
    description_md = $2,
    date           = $3,
    times          = $4,
    line           = $5
WHERE id = $6
RETURNING id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
`

type UpdateTrackParams struct {
	Name          pgtype.Text
	DescriptionMd pgtype.Text
	Date          pgtype.Timestamptz
	Times         pgtype.Array[pgtype.Timestamptz]
	Line          Geometry
	ID            pgtype.UUID
}

// UpdateTrack
//
//	UPDATE tracks
//	SET name           = $1,
//	    description_md = $2,
//	    date           = $3,
//	    times          = $4,
//	    line           = $5
//	WHERE id = $6
//	RETURNING id, owner_id, name, description_md, date, date_uploaded, length_meters, duration_secs, times, line, line_feature_id
func (q *Queries) UpdateTrack(ctx context.Context, db DBTX, arg UpdateTrackParams) (Track, error) {
	row := db.QueryRow(ctx, updateTrack,
		arg.Name,
		arg.DescriptionMd,
		arg.Date,
		arg.Times,
		arg.Line,
		arg.ID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.DescriptionMd,
		&i.Date,
		&i.DateUploaded,
		&i.LengthMeters,
		&i.DurationSecs,
		&i.Times,
		&i.Line,
		&i.LineFeatureID,
	)
	return i, err
}
